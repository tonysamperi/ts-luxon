<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="./">
  <title data-ice="title">Manual | Luxon</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<style>.luxon-title {font-size: 22px; color: black;}</style><meta name="description" content="Immutable date wrapper"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Luxon"><meta property="twitter:description" content="Immutable date wrapper"></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header><a href="../index.html" class="luxon-title">Luxon</a>
  <a href="./">Manual</a>
  
  <a href="identifiers.html">Reference</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/tonysamperi/ts-luxon"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/install.html"><a href="manual/install.html" data-ice="link">Install guide</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/install.html"><a href="manual/install.html#basic-browser-setup" data-ice="link">Basic browser setup</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/install.html"><a href="manual/install.html#internet-explorer" data-ice="link">Internet Explorer</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/install.html"><a href="manual/install.html#node" data-ice="link">Node</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/install.html"><a href="manual/install.html#amd--system-js--requirejs--etc-" data-ice="link">AMD (System.js, RequireJS, etc)</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/install.html"><a href="manual/install.html#es6" data-ice="link">ES6</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/install.html"><a href="manual/install.html#webpack" data-ice="link">Webpack</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/install.html"><a href="manual/install.html#types" data-ice="link">Types</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/install.html"><a href="manual/install.html#react-native" data-ice="link">React Native</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/tour.html"><a href="manual/tour.html" data-ice="link">A quick tour</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tour.html"><a href="manual/tour.html#your-first-datetime" data-ice="link">Your first DateTime</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tour.html"><a href="manual/tour.html#creating-a-datetime" data-ice="link">Creating a DateTime</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/tour.html"><a href="manual/tour.html#get-the-current-date-and-time" data-ice="link">Get the current date and time</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/tour.html"><a href="manual/tour.html#create-from-an-object" data-ice="link">Create from an object</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/tour.html"><a href="manual/tour.html#parse-from-iso-8601" data-ice="link">Parse from ISO 8601</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tour.html"><a href="manual/tour.html#getting-to-know-your-datetime-instance" data-ice="link">Getting to know your DateTime instance</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/tour.html"><a href="manual/tour.html#tostring" data-ice="link">toString</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/tour.html"><a href="manual/tour.html#getting-at-components" data-ice="link">Getting at components</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/tour.html"><a href="manual/tour.html#other-fun-accessors" data-ice="link">Other fun accessors</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tour.html"><a href="manual/tour.html#formatting-your-datetime" data-ice="link">Formatting your DateTime</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tour.html"><a href="manual/tour.html#transforming-your-datetime" data-ice="link">Transforming your DateTime</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/tour.html"><a href="manual/tour.html#immutability" data-ice="link">Immutability</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/tour.html"><a href="manual/tour.html#math" data-ice="link">Math</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/tour.html"><a href="manual/tour.html#set" data-ice="link">Set</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tour.html"><a href="manual/tour.html#intl" data-ice="link">Intl</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tour.html"><a href="manual/tour.html#time-zones" data-ice="link">Time zones</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tour.html"><a href="manual/tour.html#durations" data-ice="link">Durations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tour.html"><a href="manual/tour.html#intervals" data-ice="link">Intervals</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/intl.html"><a href="manual/intl.html" data-ice="link">Intl</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/intl.html"><a href="manual/intl.html#making-sure-you-have-access-to-other-locales" data-ice="link">Making sure you have access to other locales</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/intl.html"><a href="manual/intl.html#how-locales-work" data-ice="link">How locales work</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/intl.html"><a href="manual/intl.html#setting-the-locale" data-ice="link">Setting the locale</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/intl.html"><a href="manual/intl.html#default-locale" data-ice="link">Default locale</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/intl.html"><a href="manual/intl.html#out-of-the-box-behavior" data-ice="link">Out-of-the-box behavior</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/intl.html"><a href="manual/intl.html#setting-the-default" data-ice="link">Setting the default</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/intl.html"><a href="manual/intl.html#using-the-system-locale-in-string-parsing" data-ice="link">Using the system locale in string parsing</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/intl.html"><a href="manual/intl.html#checking-what-you-got" data-ice="link">Checking what you got</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/intl.html"><a href="manual/intl.html#methods-affected-by-the-locale" data-ice="link">Methods affected by the locale</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/intl.html"><a href="manual/intl.html#formatting" data-ice="link">Formatting</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/intl.html"><a href="manual/intl.html#parsing" data-ice="link">Parsing</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/intl.html"><a href="manual/intl.html#listing" data-ice="link">Listing</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/intl.html"><a href="manual/intl.html#numberingsystem" data-ice="link">numberingSystem</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/zones.html"><a href="manual/zones.html" data-ice="link">Time zones and offsets</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/zones.html"><a href="manual/zones.html#don--39-t-worry-" data-ice="link">Don&apos;t worry!</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/zones.html"><a href="manual/zones.html#terminology" data-ice="link">Terminology</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/zones.html"><a href="manual/zones.html#luxon-works-with-time-zones" data-ice="link">Luxon works with time zones</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/zones.html"><a href="manual/zones.html#specifying-a-zone" data-ice="link">Specifying a zone</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/zones.html"><a href="manual/zones.html#iana-support" data-ice="link">IANA support</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/zones.html"><a href="manual/zones.html#creating-datetimes" data-ice="link">Creating DateTimes</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/zones.html"><a href="manual/zones.html#local-by-default" data-ice="link">Local by default</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/zones.html"><a href="manual/zones.html#creating-datetimes-in-a-zone" data-ice="link">Creating DateTimes in a zone</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/zones.html"><a href="manual/zones.html#strings-that-specify-an-offset" data-ice="link">Strings that specify an offset</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/zones.html"><a href="manual/zones.html#setzone" data-ice="link">setZone</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/zones.html"><a href="manual/zones.html#changing-zones" data-ice="link">Changing zones</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/zones.html"><a href="manual/zones.html#setzone" data-ice="link">setZone</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/zones.html"><a href="manual/zones.html#keeplocaltime" data-ice="link">keepLocalTime</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/zones.html"><a href="manual/zones.html#accessors" data-ice="link">Accessors</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/zones.html"><a href="manual/zones.html#dst-weirdness" data-ice="link">DST weirdness</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/zones.html"><a href="manual/zones.html#invalid-times" data-ice="link">Invalid times</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/zones.html"><a href="manual/zones.html#ambiguous-times" data-ice="link">Ambiguous times</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/zones.html"><a href="manual/zones.html#math-across-dsts" data-ice="link">Math across DSTs</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/zones.html"><a href="manual/zones.html#changing-the-default-zone" data-ice="link">Changing the default zone</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/calendars.html"><a href="manual/calendars.html" data-ice="link">Calendars</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/calendars.html"><a href="manual/calendars.html#fully-supported-calendars" data-ice="link">Fully supported calendars</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/calendars.html"><a href="manual/calendars.html#output-calendars" data-ice="link">Output calendars</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/calendars.html"><a href="manual/calendars.html#generally-supported-calendars" data-ice="link">Generally supported calendars</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/calendars.html"><a href="manual/calendars.html#default-output-calendar" data-ice="link">Default output calendar</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/formatting.html"><a href="manual/formatting.html" data-ice="link">Formatting</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/formatting.html"><a href="manual/formatting.html#technical-formats--strings-for-computers-" data-ice="link">Technical formats (strings for computers)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#iso-8601" data-ice="link">ISO 8601</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#http-and-rfc-2822" data-ice="link">HTTP and RFC 2822</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#unix-timestamps" data-ice="link">Unix timestamps</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/formatting.html"><a href="manual/formatting.html#tolocalestring--strings-for-humans-" data-ice="link">toLocaleString (strings for humans)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#the-basics" data-ice="link">The basics</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#intl-datetimeformat" data-ice="link">Intl.DateTimeFormat</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#presets" data-ice="link">Presets</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#intl" data-ice="link">Intl</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/formatting.html"><a href="manual/formatting.html#formatting-with-tokens--strings-for-cthulhu-" data-ice="link">Formatting with tokens (strings for Cthulhu)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#consider-alternatives" data-ice="link">Consider alternatives</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#toformat" data-ice="link">toFormat</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#intl" data-ice="link">Intl</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#escaping" data-ice="link">Escaping</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#standalone-vs-format-tokens" data-ice="link">Standalone vs format tokens</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#macro-tokens" data-ice="link">Macro tokens</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/formatting.html"><a href="manual/formatting.html#table-of-tokens" data-ice="link">Table of tokens</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/parsing.html"><a href="manual/parsing.html" data-ice="link">Parsing</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/parsing.html"><a href="manual/parsing.html#parsing-technical-formats" data-ice="link">Parsing technical formats</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/parsing.html"><a href="manual/parsing.html#iso-8601" data-ice="link">ISO 8601</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/parsing.html"><a href="manual/parsing.html#http-and-rfc2822" data-ice="link">HTTP and RFC2822</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/parsing.html"><a href="manual/parsing.html#sql" data-ice="link">SQL</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/parsing.html"><a href="manual/parsing.html#unix-timestamps" data-ice="link">Unix timestamps</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/parsing.html"><a href="manual/parsing.html#ad-hoc-parsing" data-ice="link">Ad-hoc parsing</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/parsing.html"><a href="manual/parsing.html#consider-alternatives" data-ice="link">Consider alternatives</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/parsing.html"><a href="manual/parsing.html#fromformat" data-ice="link">fromFormat</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/parsing.html"><a href="manual/parsing.html#intl" data-ice="link">Intl</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/parsing.html"><a href="manual/parsing.html#limitations" data-ice="link">Limitations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/parsing.html"><a href="manual/parsing.html#debugging" data-ice="link">Debugging</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/parsing.html"><a href="manual/parsing.html#table-of-tokens" data-ice="link">Table of tokens</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/math.html"><a href="manual/math.html" data-ice="link">Math</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/math.html"><a href="manual/math.html#calendar-math-vs-time-math" data-ice="link">Calendar math vs time math</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/math.html"><a href="manual/math.html#the-basics" data-ice="link">The basics</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/math.html"><a href="manual/math.html#which-units-use-which-math-" data-ice="link">Which units use which math?</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/math.html"><a href="manual/math.html#how-to-think-about-calendar-math" data-ice="link">How to think about calendar math</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/math.html"><a href="manual/math.html#dsts" data-ice="link">DSTs</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/math.html"><a href="manual/math.html#time-math" data-ice="link">Time math</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/math.html"><a href="manual/math.html#math-with-multiple-units" data-ice="link">Math with multiple units</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/math.html"><a href="manual/math.html#comparing-datetimes" data-ice="link">Comparing DateTimes</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/math.html"><a href="manual/math.html#duration-math" data-ice="link">Duration math</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/math.html"><a href="manual/math.html#basics" data-ice="link">Basics</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/math.html"><a href="manual/math.html#diffs" data-ice="link">Diffs</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/math.html"><a href="manual/math.html#casual-vs-longterm-conversion-accuracy" data-ice="link">Casual vs longterm conversion accuracy</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/math.html"><a href="manual/math.html#losing-information" data-ice="link">Losing information</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/errors.html"><a href="manual/errors.html" data-ice="link">Errors</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errors.html"><a href="manual/errors.html#invaliduniterror" data-ice="link">InvalidUnitError</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errors.html"><a href="manual/errors.html#unitoutofrangeerror" data-ice="link">UnitOutOfRangeError</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errors.html"><a href="manual/errors.html#invalidzoneerror" data-ice="link">InvalidZoneError</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errors.html"><a href="manual/errors.html#missingplatformfeatureerror" data-ice="link">MissingPlatformFeatureError</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errors.html"><a href="manual/errors.html#conflictingspecificationerror" data-ice="link">ConflictingSpecificationError</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errors.html"><a href="manual/errors.html#invalidargumenterror" data-ice="link">InvalidArgumentError</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errors.html"><a href="manual/errors.html#debugging-invalid-datetimes" data-ice="link">Debugging invalid DateTimes</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/errors.html"><a href="manual/errors.html#invalidreason-and-invalidexplanation" data-ice="link">invalidReason and invalidExplanation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/errors.html"><a href="manual/errors.html#throwoninvalid" data-ice="link">throwOnInvalid</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errors.html"><a href="manual/errors.html#invalid-durations" data-ice="link">Invalid Durations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errors.html"><a href="manual/errors.html#invalid-intervals" data-ice="link">Invalid Intervals</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/matrix.html"><a href="manual/matrix.html" data-ice="link">Support matrix</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/matrix.html"><a href="manual/matrix.html#official-support" data-ice="link">Official support</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/matrix.html"><a href="manual/matrix.html#internet-explorer-and-platform-polyfills" data-ice="link">Internet Explorer and platform polyfills</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/matrix.html"><a href="manual/matrix.html#effects-of-missing-features" data-ice="link">Effects of missing features</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/matrix.html"><a href="manual/matrix.html#polyfills" data-ice="link">Polyfills</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/matrix.html"><a href="manual/matrix.html#intl" data-ice="link">Intl</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/matrix.html"><a href="manual/matrix.html#intl-tokens" data-ice="link">Intl tokens</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/matrix.html"><a href="manual/matrix.html#zones" data-ice="link">Zones</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/matrix.html"><a href="manual/matrix.html#older-platforms" data-ice="link">Older platforms</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/matrix.html"><a href="manual/matrix.html#other-platforms" data-ice="link">Other platforms</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/moment.html"><a href="manual/moment.html" data-ice="link">For Moment users</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/moment.html"><a href="manual/moment.html#immutability" data-ice="link">Immutability</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/moment.html"><a href="manual/moment.html#major-functional-differences" data-ice="link">Major functional differences</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/moment.html"><a href="manual/moment.html#other-api-style-differences" data-ice="link">Other API style differences</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/moment.html"><a href="manual/moment.html#datetime-method-equivalence" data-ice="link">DateTime method equivalence</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/moment.html"><a href="manual/moment.html#creation" data-ice="link">Creation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/moment.html"><a href="manual/moment.html#getters-and-setters" data-ice="link">Getters and setters</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/moment.html"><a href="manual/moment.html#basic-information-getters" data-ice="link">Basic information getters</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/moment.html"><a href="manual/moment.html#unit-getters" data-ice="link">Unit getters</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/moment.html"><a href="manual/moment.html#programmatic-get-and-set" data-ice="link">Programmatic get and set</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/moment.html"><a href="manual/moment.html#transformation" data-ice="link">Transformation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/moment.html"><a href="manual/moment.html#query" data-ice="link">Query</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/moment.html"><a href="manual/moment.html#output" data-ice="link">Output</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/moment.html"><a href="manual/moment.html#basics" data-ice="link">Basics</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/moment.html"><a href="manual/moment.html#humanization" data-ice="link">Humanization</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/moment.html"><a href="manual/moment.html#durations" data-ice="link">Durations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/moment.html"><a href="manual/moment.html#intervals" data-ice="link">Intervals</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/why.html"><a href="manual/why.html" data-ice="link">Why does Luxon exist?</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/why.html"><a href="manual/why.html#a-disclaimer" data-ice="link">A disclaimer</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/why.html"><a href="manual/why.html#origin" data-ice="link">Origin</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/why.html"><a href="manual/why.html#ideas-in-luxon" data-ice="link">Ideas in Luxon</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/why.html"><a href="manual/why.html#place-in-the-moment-project" data-ice="link">Place in the Moment project</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/why.html"><a href="manual/why.html#future-plans" data-ice="link">Future plans</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/CHANGELOG.html"><a href="manual/CHANGELOG.html" data-ice="link">Changelog</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/CHANGELOG.html"><a href="manual/CHANGELOG.html#before-2-0-0" data-ice="link">before 2.0.0</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/CHANGELOG.html"><a href="manual/CHANGELOG.html#2-0-1" data-ice="link">2.0.1</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/CHANGELOG.html"><a href="manual/CHANGELOG.html#2-0-2" data-ice="link">2.0.2</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/CONTRIBUTING.html"><a href="manual/CONTRIBUTING.html" data-ice="link">Contributing to Luxon</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/CONTRIBUTING.html"><a href="manual/CONTRIBUTING.html#general-guidelines" data-ice="link">General guidelines</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/CONTRIBUTING.html"><a href="manual/CONTRIBUTING.html#building-and-testing" data-ice="link">Building and testing</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/CONTRIBUTING.html"><a href="manual/CONTRIBUTING.html#osx" data-ice="link">OSX</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/CONTRIBUTING.html"><a href="manual/CONTRIBUTING.html#linux" data-ice="link">Linux</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/CONTRIBUTING.html"><a href="manual/CONTRIBUTING.html#windows" data-ice="link">Windows</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/CONTRIBUTING.html"><a href="manual/CONTRIBUTING.html#docker" data-ice="link">Docker</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/CONTRIBUTING.html"><a href="manual/CONTRIBUTING.html#patch-basics" data-ice="link">Patch basics</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/CONTRIBUTING.html"><a href="manual/CONTRIBUTING.html#npm-script-reference" data-ice="link">npm script reference</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  <div class="manual-user-index" data-ice="manualUserIndex"><h1 id="luxon-documentation">Luxon Documentation</h1><p>This is the manual for Luxon. You&apos;ll find guides below and an API doc reference <a href="identifiers.html">here</a>.</p>
</div>

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Install guide</h1><p>Luxon provides different builds for different JS environments. See below for a link to the right one and instructions on how to use it. Luxon supports all modern platforms, but see <a href="./manual/matrix.html">the support matrix</a> for additional details.</p><h2>Basic browser setup</h2><ul>
<li><a href="./manual/../../global/luxon.js">Download full</a></li>
<li><a href="./manual/../../global/luxon.min.js">Download minified</a></li>
</ul><p>You can also load the files from a <a href="https://www.jsdelivr.com/package/npm/luxon">CDN</a>.</p><p>Just include Luxon in a script tag. You can access its various classes through the <code>luxon</code> global.</p><pre><code class="lang-html"><code class="source-code prettyprint">&lt;script src=&quot;luxon.js&quot;&gt;&lt;/script&gt;</code>
</code></pre><p>You may wish to alias the classes you use:</p><pre><code class="lang-js"><code class="source-code prettyprint">var DateTime = luxon.DateTime;</code>
</code></pre><h3>Internet Explorer</h3><p>If you&apos;re supporting IE 10 or 11, you need some polyfills to get Luxon to work. Use polyfill.io:</p><pre><code class="lang-html"><code class="source-code prettyprint">&lt;script src=&quot;https://cdn.polyfill.io/v3/polyfill.js?features=default,String.prototype.repeat,Array.prototype.find,Array.prototype.findIndex,Math.trunc,Math.sign,Object.is&quot;&gt;&lt;/script&gt;</code>
</code></pre><p>See the <a href="./manual/matrix.html">support matrix</a> for more information on what works and what doesn&apos;t in IE.</p><h2>Node</h2><p>Supports Node 6+. Install via NPM:</p><pre><code><code class="source-code prettyprint">npm install --save luxon</code>
</code></pre><pre><code class="lang-js"><code class="source-code prettyprint">const { DateTime } = require(&quot;luxon&quot;);</code>
</code></pre><p>If you want to work with locales, you&apos;ll need to have <code>full-icu</code> support installed in Node. You can <a href="https://github.com/nodejs/node/wiki/Intl">build Node with it</a>, use an <a href="https://www.npmjs.com/package/full-icu">NPM module</a> to provide it, or find it prepackaged for your platform, like <code>brew install node --with-full-icu</code>. If you skip this step, Luxon still works but methods like <code>setLocale()</code> will do nothing.</p><p>The instructions for using full-icu as a package are a little confusing. Node can&apos;t automatically discover that you&apos;ve installed the it, so you need to tell it where to find the data, like this:</p><pre><code><code class="source-code prettyprint">npm install full-icu
node --icu-data-dir=./node_modules/full-icu</code>
</code></pre><p>You can also point to the data with an environment var, like this:</p><pre><code><code class="source-code prettyprint">NODE_ICU_DATA=&quot;$(pwd)/node_modules/full-icu&quot; node</code>
</code></pre><h2>AMD (System.js, RequireJS, etc)</h2><ul>
<li><a href="./manual/../../amd/luxon.js">Download full</a></li>
<li><a href="./manual/../../amd/luxon.min.js">Download minified</a></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">requirejs([&quot;luxon&quot;], function(luxon) {
  //...
});</code>
</code></pre><h2>ES6</h2><ul>
<li><a href="./manual/../../es6/luxon.js">Download full</a></li>
<li><a href="./manual/../../es6/luxon.min.js">Download minified</a></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">import { DateTime } from &quot;luxon&quot;;</code>
</code></pre><h2>Webpack</h2><pre><code><code class="source-code prettyprint">npm install --save luxon</code>
</code></pre><pre><code class="lang-js"><code class="source-code prettyprint">import { DateTime } from &quot;luxon&quot;;</code>
</code></pre><h2>Types</h2><p>There are third-party typing files for Flow (via <a href="https://github.com/flowtype/flow-typed">flow-typed</a>) and TypeScript (via <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a>).</p><p>For Flow, use:</p><pre><code><code class="source-code prettyprint">flow-typed install luxon</code>
</code></pre><p>For TypeScript, use:</p><pre><code><code class="source-code prettyprint">npm install --save-dev @types/luxon</code>
</code></pre><h2>React Native</h2><p>React Native works just fine, but React Native for Android doesn&apos;t ship with Intl support, which you need for <a href="./manual/matrix.html">a lot of Luxon&apos;s functionality</a>. Use <a href="https://github.com/SoftwareMansion/jsc-android-buildscripts">jsc-android-buildscripts</a> to fix it.</p></div>
        <a data-ice="link" href="manual/install.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>A quick tour</h1><p>Luxon is a library that makes it easier to work with dates and times in Javascript. If you want, add and subtract them, format and parse them, ask them hard questions, and so on, Luxon provides a much easier and comprehensive interface than the native types it wraps. We&apos;re going to talk about the most immediately useful subset of that interface.</p><p>This is going to be a bit brisk, but keep in mind that the API docs are comprehensive, so if you want to know more, feel free to <a href="./manual/../identifiers.html">dive into them</a>.</p><h2>Your first DateTime</h2><p>The most important class in Luxon is <a href="./manual/../class/src/datetime.js~DateTime.html">DateTime</a>. A DateTime represents a specific millisecond in time, along with a time zone and a locale. Here&apos;s one that represents May 15, 2017 at 8:30 in the morning in the local time zone:</p><pre><code class="lang-js"><code class="source-code prettyprint">var dt = DateTime.local(2017, 5, 15, 8, 30);</code>
</code></pre><p><a href="./manual/../class/src/datetime.js~DateTime.html#static-method-local">DateTime.local</a> takes any number of arguments, all the way out to milliseconds. Underneath, this is similar to a Javascript Date object. But we&apos;ve decorated it with lots of useful methods.</p><h2>Creating a DateTime</h2><p>There are lots of ways to create a DateTime by parsing strings or constructing them out of parts. You&apos;ve already seen one, <code>DateTime.local()</code>, but let&apos;s talk about three more.</p><h3>Get the current date and time</h3><p>To get the current time, just do this:</p><pre><code class="lang-js"><code class="source-code prettyprint">var now = DateTime.now();</code>
</code></pre><p>Calling <a href="./manual/../class/src/datetime.js~DateTime.html#static-method-now">DateTime.now</a> is equivalent to calling <code>local()</code> with no parameter.</p><h3>Create from an object</h3><p>The most powerful way to create a DateTime instance is to provide an object containing all the information:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt = DateTime.fromObject({day: 22, hour: 12, zone: &apos;America/Los_Angeles&apos;, numberingSystem: &apos;beng&apos;})</code>
</code></pre><p>Don&apos;t worry too much about the properties you don&apos;t understand yet; the point is that you can set every attribute of a DateTime when you create it. One thing to notice from the example is that we just set the day and hour; the year and month get defaulted to the current one and the minutes, seconds, and milliseconds get defaulted to 0. So <a href="./manual/../class/src/datetime.js~DateTime.html#static-method-fromObject">DateTime.fromObject</a> is sort of the power user interface.</p><h3>Parse from ISO 8601</h3><p>Luxon has lots of parsing capabilities, but the most important one is parsing <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> strings, because they&apos;re more-or-less the standard wire format for dates and times. Use <a href="./manual/../class/src/datetime.js~DateTime.html#static-method-fromISO">DateTime.fromISO</a>.</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromISO(&quot;2017-05-15&quot;)          //=&gt; May 15, 2017 at midnight
DateTime.fromISO(&quot;2017-05-15T08:30:00&quot;) //=&gt; May 15, 2017 at 8:30</code>
</code></pre><p>You can parse a bunch of other formats, including <a href="./manual/parsing.html">your own custom ones</a>.</p><h2>Getting to know your DateTime instance</h2><p>Now that we&apos;ve made some DateTimes, let&apos;s see what we can ask of it.</p><h3>toString</h3><p>The first thing we want to see is the DateTime as a string. Luxon returns ISO 8601 strings:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.now().toString(); //=&gt; &apos;2017-09-14T03:20:34.091-04:00&apos;</code>
</code></pre><h3>Getting at components</h3><p>We can get at the components of the time individually through getters. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt = DateTime.now();
dt.year     //=&gt; 2017
dt.month    //=&gt; 9
dt.day      //=&gt; 14
dt.second   //=&gt; 47
dt.weekday  //=&gt; 4</code>
</code></pre><h3>Other fun accessors</h3><pre><code class="lang-js"><code class="source-code prettyprint">dt.zoneName     //=&gt; &apos;America/New_York&apos;
dt.offset       //=&gt; -240
dt.daysInMonth  //=&gt; 30</code>
</code></pre><p>There are lots more!</p><h2>Formatting your DateTime</h2><p>You may want to output your DateTime to a string for a machine or a human to read. Luxon has lots of tools for this, but two of them are most important. If you want to format a human-readable string, use <code>toLocaleString</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.toLocaleString()      //=&gt; &apos;9/14/2017&apos;
dt.toLocaleString(DateTime.DATETIME_MED) //=&gt; &apos;September 14, 3:21 AM&apos;</code>
</code></pre><p>This works well across different locales (languages) by letting the browser figure out what order the different parts go in and how to punctuate them.</p><p>If you want the string read by another program, you almost certainly want to use <code>toISO</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.toISO() //=&gt; &apos;2017-09-14T03:21:47.070-04:00&apos;</code>
</code></pre><p>Custom formats are also supported. See <a href="./manual/formatting">formatting</a>.</p><h2>Transforming your DateTime</h2><h3>Immutability</h3><p>Luxon objects are immutable. That means that you can&apos;t alter them in place, just create altered copies. Throughout the documentation, we use terms like &quot;alter&quot;, &quot;change&quot;, and &quot;set&quot; loosely, but rest assured we mean &quot;create a new instance with different properties&quot;.</p><h3>Math</h3><p>This is easier to show than to tell. All of these calls return new DateTime instances:</p><pre><code class="lang-js"><code class="source-code prettyprint">var dt = DateTime.now();
dt.plus({ hours: 3, minutes: 2 });
dt.minus({ days: 7 });
dt.startOf(&apos;day&apos;);
dt.endOf(&apos;hour&apos;);</code>
</code></pre><h3>Set</h3><p>You can create new instances by overriding specific properties:</p><pre><code class="lang-js"><code class="source-code prettyprint">var dt = DateTime.now();
dt.set({hour: 3}).hour   //=&gt; 3</code>
</code></pre><h2>Intl</h2><p>Luxon provides several different Intl capabilities, but the most important one is in formatting:</p><pre><code class="lang-js"><code class="source-code prettyprint">var dt = DateTime.now();
var f = {month: &apos;long&apos;, day: &apos;numeric&apos;};
dt.setLocale(&apos;fr&apos;).toLocaleString(f)      //=&gt; &apos;14 septembre&apos;
dt.setLocale(&apos;en-GB&apos;).toLocaleString(f)   //=&gt; &apos;14 September&apos;
dt.setLocale(&apos;en-US&apos;).toLocaleString(f)  //=&gt; &apos;September 14&apos;</code>
</code></pre><p>Luxon&apos;s Info class can also list months or weekdays for different locales:</p><pre><code class="lang-js"><code class="source-code prettyprint">Info.months(&apos;long&apos;, {locale: &apos;fr&apos;}) //=&gt; [ &apos;janvier&apos;, &apos;f&#xE9;vrier&apos;, &apos;mars&apos;, &apos;avril&apos;, ... ]</code>
</code></pre><h2>Time zones</h2><p>Luxon supports time zones. There&apos;s a whole <a href="./manual/zones">big section</a> about it. But briefly, you can create DateTimes in specific zones and change their zones:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromObject({zone: &apos;America/Los_Angeles&apos;}) // now, but expressed in LA&apos;s local time
DateTime.now().setZone(&apos;America/Los_Angeles&apos;); // same</code>
</code></pre><p>Luxon also supports UTC directly:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.utc(2017, 5, 15);
DateTime.utc(); // now, in UTC time zone
DateTime.now().toUTC();
DateTime.utc().toSystemZone();</code>
</code></pre><h2>Durations</h2><p>The Duration class represents a quantity of time such as &quot;2 hours and 7 minutes&quot;. You create them like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">var dur = Duration.fromObject({ hours: 2, minutes: 7 });</code>
</code></pre><p>They can be add or subtracted from DateTimes like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.plus(dur);</code>
</code></pre><p>They have getters just like DateTime:</p><pre><code class="lang-js"><code class="source-code prettyprint">dur.hours   //=&gt; 2
dur.minutes //=&gt; 7
dur.seconds //=&gt; 0</code>
</code></pre><p>And some other useful stuff:</p><pre><code class="lang-js"><code class="source-code prettyprint">dur.as(&apos;seconds&apos;) //=&gt; 7620
dur.toObject()    //=&gt; { hours: 2, minutes: 7 }
dur.toISO()       //=&gt; &apos;PT2H7M&apos;</code>
</code></pre><p>You can also format, negate, and normalize them. See it all in the <a href="./manual/../class/src/duration.js~Duration.html">Duration API docs</a>.</p><h2>Intervals</h2><p>Intervals are a specific period of time, such as &quot;between now and midnight&quot;. They&apos;re really a wrapper for two DateTimes that form its endpoints. Here&apos;s what you can do with them:</p><pre><code class="lang-js"><code class="source-code prettyprint">now = DateTime.now();
later = DateTime.local(2020, 10, 12);
i = Interval.fromDateTimes(now, later);

i.length()                             //=&gt; 97098768468
i.length(&apos;years&apos;)                //=&gt; 3.0762420239726027
i.contains(DateTime.local(2019))       //=&gt; true

i.toISO()       //=&gt; &apos;2017-09-14T04:07:11.532-04:00/2020-10-12T00:00:00.000-04:00&apos;
i.toString()    //=&gt; &apos;[2017-09-14T04:07:11.532-04:00 &#x2013; 2020-10-12T00:00:00.000-04:00)</code>
</code></pre><p>Intervals can be split up into smaller intervals, perform set-like operations with other intervals, and few other handy features. See the <a href="./manual/../class/src/interval.js~Interval.html">Interval API docs</a>.</p></div>
        <a data-ice="link" href="manual/tour.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Intl</h1><p>Luxon uses the native Intl API to provide easy-to-use internationalization. A quick example:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.now()
  .setLocale(&quot;el&quot;)
  .toLocaleString(DateTime.DATE_FULL); //=&gt;  &apos;24 &#x3A3;&#x3B5;&#x3C0;&#x3C4;&#x3B5;&#x3BC;&#x3B2;&#x3C1;&#x3AF;&#x3BF;&#x3C5; 2017&apos;</code>
</code></pre><h2>Making sure you have access to other locales</h2><p>Please see the <a href="./manual/install.html">install guide</a> for instructions on making sure your platform has access to the Intl APIs and the ICU data to power it. This especially important for Node, which doesn&apos;t ship with ICU data by default.</p><h2>How locales work</h2><p>Luxon DateTimes can be configured using <a href="https://tools.ietf.org/html/rfc5646">BCP 47</a> locale strings specifying the language to use generating or interpreting strings. The native Intl API provides the actual internationalized strings; Luxon just wraps it with a nice layer of convenience and integrates the localization functionality into the rest of Luxon. The Mozilla MDN Intl docs have a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation">good description</a> of how the <code>locale</code> argument works. In Luxon, the methods are different but the semantics are the same, except in that Luxon allows you to specify a numbering system and output calendar independently of the locale string.</p><p>The rest of this document will concentrate on what Luxon does when provided with locale information.</p><h2>Setting the locale</h2><p><code>locale</code> is a property of Luxon object. Thus, locale is a sort of setting on the DateTime object, as opposed to an argument you provide the different methods that need internationalized.</p><p>You can generally set it at construction time:</p><pre><code class="lang-js"><code class="source-code prettyprint">var dt = DateTime.fromISO(&quot;2017-09-24&quot;, { locale: &quot;fr&quot; });
dt.locale; //=&gt; &apos;fr&apos;</code>
</code></pre><p>In this case, the specified locale didn&apos;t change the how the parsing worked (there&apos;s nothing localized about it), but it did set the locale property in the resulting instance. For other factory methods, such as <code>fromFormat</code>, the locale argument <em>does</em> affect how the string is parsed. See further down for more.</p><p>You can change the locale of a DateTime instance (meaning, create a clone DateTime with a different locale) using <code>setLocale</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.now().setLocale(&quot;fr&quot;).locale; //=&gt; &apos;fr&apos;</code>
</code></pre><p><code>setLocale</code> is just a convenience for <code>reconfigure</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.now().reconfigure({ locale: &quot;fr&quot; }).locale; //=&gt; &apos;fr&apos;</code>
</code></pre><h2>Default locale</h2><h3>Out-of-the-box behavior</h3><p>By default, the <code>locale</code> property of a new DateTime or Duration is the system locale. On a browser, that means whatever the user has their browser or OS language set to. On Node, that usually means en-US.</p><p>As a result, <code>DateTime#toLocaleString</code>, <code>DateTime#toLocaleParts</code>, and other human-readable-string methods like <code>Info.months</code> will by default generate strings in the user&apos;s locale.</p><p>However, note that <code>DateTime.fromFormat</code> and <code>DateTime#toFormat</code> fall back on en-US. That&apos;s because these methods are often used to parse or format strings for consumption by APIs that don&apos;t care about the user&apos;s locale. So we need to pick a locale and stick with it, or the code will break depending on whose browser it runs in. There&apos;s an exception, though: <code>DateTime#toFormat</code> can take &quot;macro&quot; formats like &quot;D&quot; that produces localized strings as part of a larger string. These _do_ default to the system locale because their entire purpose is to be provide localized strings.</p><h3>Setting the default</h3><p>You can set a default locale so that news instances will always be created with the specified locale:</p><pre><code class="lang-js"><code class="source-code prettyprint">Settings.defaultLocale = &quot;fr&quot;;
DateTime.now().locale; //=&gt; &apos;fr&apos;</code>
</code></pre><p>Note that this also alters the behavior of <code>DateTime#toFormat</code> and <code>DateTime#fromFormat</code>.</p><h3>Using the system locale in string parsing</h3><p>You generally don&apos;t want <code>DateTime#fromFormat</code> and <code>DateTime#toFormat</code> to use the system&apos;s locale, since your format won&apos;t be sensitive to the locale&apos;s string ordering. That&apos;s why Luxon doesn&apos;t behave that way by default. But if you really want that behavior, you can always do this:</p><pre><code class="lang-js"><code class="source-code prettyprint">Settings.defaultLocale = DateTime.now().resolvedLocaleOptions().locale;</code>
</code></pre><h2>Checking what you got</h2><p>The local environment may not support the exact locale you asked for. The native Intl API will try to find the best match. If you want to know what that match was, use <code>resolvedLocaleOptions</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromObject(null, { locale: &quot;fr-co&quot; }).resolvedLocaleOptions(); //=&gt; { locale: &apos;fr&apos;,
//     numberingSystem: &apos;latn&apos;,
//     outputCalendar: &apos;gregory&apos; }</code>
</code></pre><h2>Methods affected by the locale</h2><h3>Formatting</h3><p>The most important method affected by the locale setting is <code>toLocaleString</code>, which allows you to produce internationalized, human-readable strings.</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.setLocale(&quot;fr&quot;).toLocaleString(DateTime.DATE_FULL); //=&gt; &apos;25 septembre 2017&apos;</code>
</code></pre><p>That&apos;s the normal way to do it: set the locale as property of the DateTime itself and let the <code>toLocaleString</code> inherit it. But you can specify the locale directly to <code>toLocaleString</code> too:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.toLocaleString(Object.assign({ locale: &quot;es&quot; }, DateTime.DATE_FULL)); //=&gt; &apos;25 de septiembre de 2017&apos;</code>
</code></pre><p>Ad-hoc formatting also respects the locale:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.setLocale(&quot;fr&quot;).toFormat(&quot;MMMM dd, yyyy GG&quot;); //=&gt; &apos;septembre 25, 2017 apr&#xE8;s J&#xE9;sus-Christ&apos;</code>
</code></pre><h3>Parsing</h3><p>You can <a href="./manual/parsing.html">parse</a> localized strings:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromFormat(&quot;septembre 25, 2017 apr&#xE8;s J&#xE9;sus-Christ&quot;, &quot;MMMM dd, yyyy GG&quot;, { locale: &quot;fr&quot; });</code>
</code></pre><h3>Listing</h3><p>Some of the methods in the <a href="./manual/../class/src/info.js~Info.html">Info</a> class let you list strings like months, weekdays, and eras, and they can be localized:</p><pre><code class="lang-js"><code class="source-code prettyprint">Info.months(&quot;long&quot;, { locale: &quot;fr&quot; }); //=&gt; [ &apos;janvier&apos;, &apos;f&#xE9;vrier&apos;, ...
Info.weekdays(&quot;long&quot;, { locale: &quot;fr&quot; }); //=&gt; [ &apos;lundi&apos;, &apos;mardi&apos;, ...
Info.eras(&quot;long&quot;, { locale: &quot;fr&quot; }); //=&gt; [ &apos;avant J&#xE9;sus-Christ&apos;, &apos;apr&#xE8;s J&#xE9;sus-Christ&apos; ]</code>
</code></pre><h2>numberingSystem</h2><p>DateTimes also have a <code>numberingSystem</code> setting that lets you control what system of numerals is used in formatting. In general, you shouldn&apos;t override the numbering system provided by the locale. For example, no extra work is needed to get Arabic numbers to show up in Arabic-speaking locales:</p><pre><code class="lang-js"><code class="source-code prettyprint">const dt = DateTime.now().setLocale(&quot;ar&quot;);

dt.resolvedLocaleOptions(); //=&gt; { locale: &apos;ar&apos;,
//     numberingSystem: &apos;arab&apos;,
//     outputCalendar: &apos;gregory&apos; }

dt.toLocaleString(); //=&gt; &apos;&#x662;&#x664;&#x200F;/&#x669;&#x200F;/&#x662;&#x660;&#x661;&#x667;&apos;</code>
</code></pre><p>For this reason, Luxon defaults its own <code>numberingSystem</code> property to null, by which it means &quot;let the Intl API decide&quot;. However, you can override it if you want. This example is admittedly ridiculous:</p><pre><code class="lang-js"><code class="source-code prettyprint">const dt = DateTime.now().reconfigure({ locale: &quot;it&quot;, numberingSystem: &quot;beng&quot; });
dt.toLocaleString(DateTime.DATE_FULL); //=&gt; &apos;&#x9E8;&#x9EA; settembre &#x9E8;&#x9E6;&#x9E7;&#x9ED;&apos;</code>
</code></pre><p>Similar to <code>locale</code>, you can set the default numbering system for new instances:</p><pre><code class="lang-js"><code class="source-code prettyprint">Settings.defaultNumberingSystem = &quot;beng&quot;;</code>
</code></pre></div>
        <a data-ice="link" href="manual/intl.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Time zones and offsets</h1><p>Luxon has support for time zones. This page explains how to use them.</p><h2>Don&apos;t worry!</h2><p>You <em>usually</em> don&apos;t need to worry about time zones. Your code runs on a computer with a particular time zone and everything will work consistently in that zone without you doing anything. It&apos;s when you want to do complicated stuff <em>across</em> zones that you have to think about it. Even then, here are some pointers to help you avoid situations where you have to think carefully about time zones:</p><ol>
<li>Don&apos;t make servers think about <em>local</em> times. Configure them to use UTC and write your server&apos;s code to work in UTC. Times can often be thought of as a simple count of epoch milliseconds; what you would call that time (e.g. 9:30) in what zone doesn&apos;t (again, often) matter.</li>
<li>Communicate times between systems in ISO 8601, like &quot;2017-05-15T13:30:34Z&quot; where possible (it doesn&apos;t matter if you use Z or some local offset; the point is that it precisely identifies the millisecond on the global timeline).</li>
<li>Where possible, only think of time zones as a formatting concern; your application ideally never knows that the time it&apos;s working with is called &quot;9:00&quot; until it&apos;s being rendered to the user.</li>
<li>Barring 3, do as much manipulation of the time (say, adding an hour to the current time) in the client code that&apos;s already running in the time zone where the results will matter.</li>
</ol><p>All those things will make it less likely you ever need to work explicitly with time zones and may also save you plenty of other headaches. But those aren&apos;t possible for some applications; you might need to work with times in zones other than the one the program is running in, for any number of reasons. And that&apos;s where Luxon&apos;s time zone support comes in.</p><h2>Terminology</h2><p>Bear with me here. Time zones are pain in the ass. Luxon has lots of tools to deal with them, but there&apos;s no getting around the fact that they&apos;re complicated. The terminology for time zones and offsets isn&apos;t well-established. But let&apos;s try to impose some order:</p><ol>
<li>An <strong>offset</strong> is a difference between the local time and the UTC time, such as +5 (hours) or -12:30. They may be expressed directly in minutes, or in hours, or in a combination of minutes and hours. Here we&apos;ll use hours.</li>
<li>A <strong>time zone</strong> is a set of rules, associated with a geographical location, that determines the local offset from UTC at any given time. The best way to identify a zone is by its IANA string, such as &quot;America/New_York&quot;. That zone says something to the effect of &quot;The offset is -4, except between March and November, when it&apos;s -5&quot;.</li>
<li>A <strong>fixed-offset time zone</strong> is any time zone that never changes offsets, such as UTC. Luxon supports fixed-offset zones directly; they&apos;re specified like UTC+7, which you can interpret as &quot;always with an offset of +7&quot;.</li>
<li>A <strong>named offset</strong> is a time zone-specific name for an offset, such as Eastern Daylight Time. It expresses both the zone (America&apos;s EST roughly implies America/New_York) and the current offset (EST means -4). They are confusing in that they overspecify the offset (e.g. for any given time it is unnecessary to specify EST vs EDT; it&apos;s always whichever one is right). They are also ambiguous (BST is both British Summer Time and Bangladesh Standard Time), unstandardized, and internationalized (what would a Frenchman call the US&apos;s EST?). For all these reasons, you should avoid them when specifying times programmatically. Luxon only supports their use in formatting.</li>
</ol><p>Some subtleties:</p><ol>
<li>Multiple zones can have the same offset (think about the US&apos;s zones and their Canadian equivalents), though they might not have the same offset all the time, depending on when their DSTs are. Thus zones and offsets have a many-to-many relationship.</li>
<li>Just because a time zone doesn&apos;t have a DST now doesn&apos;t mean it&apos;s fixed. Perhaps it had one in the past. Regardless, Luxon does not have first-class access to the list of rules, so it assumes any IANA-specified zone is not fixed and checks for its current offset programmatically.</li>
</ol><p>If all this seems too terse, check out these articles. The terminology in them is subtly different but the concepts are the same:</p><ul>
<li><a href="https://spin.atomicobject.com/2016/07/06/time-zones-offsets/">Time Zones Aren&#x2019;t Offsets &#x2013; Offsets Aren&#x2019;t Time Zones</a></li>
<li><a href="https://stackoverflow.com/tags/timezone/info">Stack Overflow&apos;s timezone wiki page</a></li>
</ul><h2>Luxon works with time zones</h2><p>Luxon&apos;s DateTime class supports zones directly. By default, a date created in Luxon is &quot;in&quot; the system&apos;s time zone (i.e. the time zone set on the machine it&apos;s running on). By &quot;in&quot; we mean that the DateTime has, as one of its properties, an associated zone.</p><p>It&apos;s important to remember that a DateTime represents a specific instant in time and that instant has an unambiguous meaning independent of what time zone you&apos;re in; the zone is really piece of social metadata that affects how humans interact with the time, rather than a fact about the passing of time itself. Of course, Luxon is a library for humans, so that social metadata affects Luxon&apos;s behavior too. It just doesn&apos;t change <em>what time it is</em>.</p><p>Specifically, a DateTime&apos;s zone affects its behavior in these ways:</p><ol>
<li>Times will be formatted as they would be in that zone.</li>
<li>Transformations to the DateTime (such as <code>plus</code> or <code>startOf</code>) will obey any DSTs in that zone that affect the calculation (see &quot;Math across DSTs&quot; below)</li>
</ol><p>Generally speaking, Luxon does not support changing a DateTime&apos;s offset, just its zone. That allows it to enforce the behaviors in the list above. The offset for that DateTime is just whatever the zone says it is. If you are unconcerned with the effects above, then you can always give your DateTime a fixed-offset zone.</p><h2>Specifying a zone</h2><p>Luxon&apos;s API methods that take a zone as an argument all let you specify the zone in a few ways.</p><table>
<thead>
<tr>
<th>Type</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IANA</td>
<td>&apos;America/New_York&apos;</td>
<td>that zone</td>
</tr>
<tr>
<td>system</td>
<td>&apos;system&apos;</td>
<td>the system&apos;s time zone (the one set on the machine)</td>
</tr>
<tr>
<td>default</td>
<td>&apos;default&apos;</td>
<td>the time zone used to create DateTimes (equals system by default)</td>
</tr>
<tr>
<td>UTC</td>
<td>&apos;utc&apos;</td>
<td>Universal Coordinated Time</td>
</tr>
<tr>
<td>fixed offset</td>
<td>&apos;UTC+7&apos;</td>
<td>a fixed offset zone</td>
</tr>
<tr>
<td>Zone</td>
<td>new YourZone()</td>
<td>A custom implementation of Luxon&apos;s Zone interface (advanced only)</td>
</tr>
</tbody>
</table><h3>IANA support</h3><p>IANA-specified zones are string identifiers like &quot;America/New_York&quot; or &quot;Asia/Tokyo&quot;. Luxon gains direct support for them by abusing built-in Intl APIs. However, your environment may not support them, in which case, you can&apos;t fiddle with the zones directly. You can always use the time zone your system is in (<code>system</code>), UTC, and any fixed-offset zone like UTC+7. You can check if your runtime environment supports IANA zones with our handy utility:</p><pre><code class="lang-js"><code class="source-code prettyprint">Info.features().zones; //=&gt; true</code>
</code></pre><p>If you&apos;re unsure if all your target environments (browser versions and Node versions) support this, check out the <a href="./manual/matrix.html">Support Matrix</a>. You can generally count on modern browsers to have this feature, except IE (it is supported in Edge). You may also <a href="./manual/matrix.html#zones">polyfill</a> your environment.</p><p>If you specify a zone and your environment doesn&apos;t support that zone, you&apos;ll get an <a href="./manual/errors.html">error</a>. That could be because the environment doesn&apos;t support zones at all, because for whatever reason it doesn&apos;t support that <em>particular</em> zone, or because the zone is just bogus. Like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">try {
  bogus = DateTime.local().setZone(&quot;America/Bogus&quot;);
} catch (e) {
  e.invalidReason; //=&gt; &apos;unsupported zone&apos;
}</code>
</code></pre><h2>Creating DateTimes</h2><h3>Local by default</h3><p>By default, DateTime instances are created in the system&apos;s time zone and parsed strings are interpreted as specifying times in the system&apos;s time zone. For example, my computer is configured to use <code>America/New_York</code>, which has an offset of -4 in May:</p><pre><code class="lang-js"><code class="source-code prettyprint">var local = DateTime.local(2017, 05, 15, 09, 10, 23);

local.zoneName; //=&gt; &apos;America/New_York&apos;
local.toString(); //=&gt; &apos;2017-05-15T09:10:23.000-04:00&apos;

var iso = DateTime.fromISO(&quot;2017-05-15T09:10:23&quot;);

iso.zoneName; //=&gt; &apos;America/New_York&apos;
iso.toString(); //=&gt; &apos;2017-05-15T09:10:23.000-04:00&apos;</code>
</code></pre><h3>Creating DateTimes in a zone</h3><p>Many of Luxon&apos;s factory methods allow you to tell it specifically what zone to create the DateTime in:</p><pre><code class="lang-js"><code class="source-code prettyprint">var overrideZone = DateTime.fromISO(&quot;2017-05-15T09:10:23&quot;, { zone: &quot;Europe/Paris&quot; });

overrideZone.zoneName; //=&gt; &apos;Europe/Paris&apos;
overrideZone.toString(); //=&gt; &apos;2017-05-15T09:10:23.000+02:00&apos;</code>
</code></pre><p>Note two things:</p><ol>
<li>The date and time specified in the string was interpreted as a Parisian local time (i.e. it&apos;s the time that corresponds to what would be called 9:10 <em>there</em>).</li>
<li>The resulting DateTime object is in Europe/Paris.</li>
</ol><p>Those are conceptually independent (i.e. Luxon could have converted that instant to the system&apos;s time zone), but in practice it&apos;s more convenient for the same option to govern both.</p><p>In addition, one static method, <code>utc()</code>, specifically interprets the input as being specified in UTC. It also returns a DateTime in UTC:</p><pre><code class="lang-js"><code class="source-code prettyprint">var utc = DateTime.utc(2017, 05, 15, 09, 10, 23);

utc.zoneName; //=&gt; &apos;UTC&apos;
utc.toString(); //=&gt; &apos;2017-05-15T09:10:23.000Z&apos;</code>
</code></pre><h3>Strings that specify an offset</h3><p>Some input strings may specify an offset as part of the string itself. In these cases, Luxon interprets the time as being specified with that offset, but converts the resulting DateTime into the system&apos;s time zone:</p><pre><code class="lang-js"><code class="source-code prettyprint">var specifyOffset = DateTime.fromISO(&quot;2017-05-15T09:10:23-09:00&quot;);

specifyOffset.zoneName; //=&gt; &apos;America/New_York&apos;
specifyOffset.toString(); //=&gt; &apos;2017-05-15T14:10:23.000-04:00&apos;

var specifyZone = DateTime.fromFormat(
  &quot;2017-05-15T09:10:23 Europe/Paris&quot;,
  &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss z&quot;
);

specifyZone.zoneName; //=&gt; &apos;America/New_York&apos;
specifyZone.toString(); //=&gt; &apos;2017-05-15T03:10:23.000-04:00&apos;</code>
</code></pre><p>...unless a zone is specified as an option (see previous section), in which case the DateTime gets converted to <em>that</em> zone:</p><pre><code class="lang-js"><code class="source-code prettyprint">var specifyOffsetAndOverrideZone = DateTime.fromISO(&quot;2017-05-15T09:10:23-09:00&quot;, {
  zone: &quot;Europe/Paris&quot;
});

specifyOffsetAndOverrideZone.zoneName; //=&gt; &apos;Europe/Paris&apos;
specifyOffsetAndOverrideZone.toString(); //=&gt; &apos;2017-05-15T20:10:23.000+02:00&apos;</code>
</code></pre><h3>setZone</h3><p>Finally, some parsing functions allow you to &quot;keep&quot; the zone in the string as the DateTime&apos;s zone. Note that if only an offset is provided by the string, the zone will be a fixed-offset one, since Luxon doesn&apos;t know which zone is meant, even if you do.</p><pre><code class="lang-js"><code class="source-code prettyprint">var keepOffset = DateTime.fromISO(&quot;2017-05-15T09:10:23-09:00&quot;, { setZone: true });

keepOffset.zoneName; //=&gt; &apos;UTC-9&apos;
keepOffset.toString(); //=&gt; &apos;2017-05-15T09:10:23.000-09:00&apos;

var keepZone = DateTime.fromFormat(&quot;2017-05-15T09:10:23 Europe/Paris&quot;, &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss z&quot;, {
  setZone: true
});

keepZone.zoneName; //=&gt; &apos;Europe/Paris&apos;
keepZone.toString(); //=&gt; &apos;2017-05-15T09:10:23.000+02:00&apos;</code>
</code></pre><h2>Changing zones</h2><h3>setZone</h3><p>Luxon objects are immutable, so when we say &quot;changing zones&quot; we really mean &quot;creating a new instance with a different zone&quot;. Changing zone generally means &quot;change the zone in which this DateTime is expressed (and according to which rules it is manipulated), but don&apos;t change the underlying timestamp.&quot; For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">var local = DateTime.local();
var rezoned = local.setZone(&quot;America/Los_Angeles&quot;);

// different times with different offsets
local.toString(); //=&gt; &apos;2017-09-13T18:30:51.141-04:00&apos;
rezoned.toString(); //=&gt; &apos;2017-09-13T15:30:51.141-07:00&apos;

// but actually the same timestamp
local.valueOf() === rezoned.valueOf(); //=&gt; true</code>
</code></pre><h3>keepLocalTime</h3><p>Generally, it&apos;s best to think of the zone as a sort of metadata that you slide around independent of the underlying count of milliseconds. However, sometimes that&apos;s not what you want. Sometimes you want to change zones while keeping the local time fixed and instead altering the timestamp. Luxon supports this:</p><pre><code class="lang-js"><code class="source-code prettyprint">var local = DateTime.local();
var rezoned = local.setZone(&quot;America/Los_Angeles&quot;, { keepLocalTime: true });

// identical times with different offsets
local.toString(); //=&gt; &apos;2017-09-13T18:36:23.187-04:00&apos;
rezoned.toString(); //=&gt; &apos;2017-09-13T18:36:23.187-07:00&apos;

local.valueOf() === rezoned.valueOf(); //=&gt; false</code>
</code></pre><p>If you find that confusing, I recommend just not using it. On the other hand, if you find yourself using this all the time, you are probably doing something wrong.</p><h2>Accessors</h2><p>Luxon DateTimes have a few different accessors that let you find out about the zone and offset:</p><pre><code class="lang-js"><code class="source-code prettyprint">var dt = DateTime.local();

dt.zoneName; //=&gt; &apos;America/New_York&apos; (for instance)
dt.offset; //=&gt; -240
dt.offsetNameShort; //=&gt; &apos;EDT&apos;
dt.offsetNameLong; //=&gt; &apos;Eastern Daylight Time&apos;
dt.isOffsetFixed; //=&gt; false
dt.isInDST; //=&gt; true</code>
</code></pre><p>Those are all documented in the <a href="./manual/../class/src/datetime.js~DateTime.html">DateTime API docs</a>.</p><h2>DST weirdness</h2><p>Because our ancestors were morons, they opted for a system wherein many governments shift around the local time twice a year for no good reason. And it&apos;s not like they do it in a neat, coordinated fashion. No, they do it whimsically, varying the shifts&apos; timing from country to country (or region to region!) and from year to year. And of course, they do it the opposite way south of the Equator. This is all a tremendous waste of everyone&apos;s energy and, er, time, but it is how the world works and a date and a time library has to deal with it.</p><p>Most of the time, DST shifts will happen without you having to do anything about it and everything will just work. Luxon goes to some pains to make DSTs as unweird as possible. But there are exceptions. This section covers them.</p><h3>Invalid times</h3><p>Some local times simply don&apos;t exist. The Spring Forward DST shift involves shifting the local time forward by (usually) one hour. In my zone, <code>America/New_York</code>, on March 12, 2017 the millisecond after 1:59:59.999 is 3:00:00.000. Thus the times between 2:00:00.000 and 2:59:59.000, inclusive, don&apos;t exist in that zone. But of course, nothing stops a user from constructing a DateTime out of that local time.</p><p>If you create such a DateTime from scratch, the missing time will be advanced by an hour:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.local(2017, 3, 12, 2, 30).toString(); //=&gt; &apos;2017-03-12T03:30:00.000-04:00&apos;</code>
</code></pre><p>You can also do date math that lands you in the middle of the shift. These also push forward:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.local(2017, 3, 11, 2, 30)
  .plus({ days: 1 })
  .toString(); //=&gt; &apos;2017-03-12T03:30:00.000-04:00&apos;
DateTime.local(2017, 3, 13, 2, 30)
  .minus({ days: 1 })
  .toString(); //=&gt; &apos;2017-03-12T03:30:00.000-04:00&apos;</code>
</code></pre><h3>Ambiguous times</h3><p>Harder to handle are ambiguous times. During Fall Back, some local times happen twice. In my zone, <code>America/New_York</code>, on November 5, 2017 the millisecond after 1:59:59.000 became 1:00:00.000. But of course there was already a 1:00 that day, one hour before before this one. So if you create a DateTime with a local time of 1:30, which time do you mean? It&apos;s an important question, because they correspond to different moments in time.</p><p>However, Luxon&apos;s behavior here is undefined. It makes no promises about which of the two possible timestamps the instance will represent. Currently, its specific behavior is like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.local(2017, 11, 5, 1, 30).offset / 60; //=&gt; -4
DateTime.local(2017, 11, 4, 1, 30).plus({ days: 1 }).offset / 60; //=&gt; -4
DateTime.local(2017, 11, 6, 1, 30).minus({ days: 1 }).offset / 60; //=&gt; -5</code>
</code></pre><p>In other words, sometimes it picks one and sometimes the other. Luxon doesn&apos;t guarantee the specific behavior above. That&apos;s just what it happens to do.</p><p>If you&apos;re curious, this lack of definition is because Luxon doesn&apos;t actually know that any particular DateTime is an ambiguous time. It doesn&apos;t know the time zones rules at all. It just knows the local time does not contradict the offset and leaves it at that. To find out the time is ambiguous and define exact rules for how to resolve it, Luxon would have to test nearby times to see if it can find duplicate local time, and it would have to do that on every creation of a DateTime, regardless of whether it was anywhere near a real DST shift. Because that&apos;s onerous, Luxon doesn&apos;t bother.</p><h3>Math across DSTs</h3><p>There&apos;s a whole <a href="./manual/math.html">section</a> about date and time math, but it&apos;s worth highlighting one thing here: when Luxon does math across DSTs, it adjusts for them when working with higher-order, variable-length units like days, weeks, months, and years. When working with lower-order, exact units like hours, minutes, and seconds, it does not. For example, DSTs mean that days are not always the same length: one day a year is (usually) 23 hours long and another is 25 hours long. Luxon makes sure that adding days takes that into account. On the other hand, an hour is always 3,600,000 milliseconds.</p><p>An easy way to think of it is that if you add a day to a DateTime, you should always get the same time the next day, regardless of any intervening DSTs. On the other hand, adding 24 hours will result in DateTime that is 24 hours later, which may or may not be the same time the next day. In this example, my zone is <code>America/New_York</code>, which had a Spring Forward DST in the early hours of March 12.</p><pre><code class="lang-js"><code class="source-code prettyprint">var start = DateTime.local(2017, 3, 11, 10);
start.hour; //=&gt; 10, just for comparison
start.plus({ days: 1 }).hour; //=&gt; 10, stayed the same
start.plus({ hours: 24 }).hour; //=&gt; 11, DST pushed forward an hour</code>
</code></pre><h2>Changing the default zone</h2><p>By default, Luxon creates DateTimes in the system&apos;s time zone, which is normally set to the local time zone where the machine that executes this code is located. However, you can override this behavior globally:</p><pre><code class="lang-js"><code class="source-code prettyprint">Settings.defaultZone = &quot;Asia/Tokyo&quot;;
DateTime.local().zoneName; //=&gt; &apos;Asia/Tokyo&apos;

Settings.defaultZone = &quot;utc&quot;;
DateTime.local().zoneName; //=&gt; &apos;UTC&apos;

// you can reset by setting to &apos;system&apos;

Settings.defaultZone = &quot;system&quot;;
DateTime.local().zoneName; //=&gt; &apos;America/New_York&apos; (for instance)</code>
</code></pre><p>Note that changing the default zone will only affect the DateTimes created <em>after</em> this change, not the existing ones.</p></div>
        <a data-ice="link" href="manual/zones.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Calendars</h1><p>This covers Luxon&apos;s support for various calendar systems. If you don&apos;t need to use non-standard calendars, you don&apos;t need to read any of this.</p><h2>Fully supported calendars</h2><p>Luxon has full support for Gregorian and ISO Week calendars. What I mean by that is that Luxon can parse dates specified in those calendars, format dates into strings using those calendars, and transform dates using the units of those calendars. For example, here is Luxon working directly with an ISO calendar:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromISO(&apos;2017-W23-3&apos;).plus({ weeks: 1, days: 2 }).toISOWeekDate(); //=&gt;  &apos;2017-W24-5&apos;</code>
</code></pre><p>The main reason I bring all this is up is to contrast it with the capabilities for other calendars described below.</p><h2>Output calendars</h2><p>Luxon has limited support for other calendaring systems. Which calendars are supported at all is a platform-dependent, but can generally be expected to be these: Buddhist, Chinese, Coptic, Ethioaa, Ethiopic, Hebrew, Indian, Islamic, Islamicc, Japanese, Persian, and ROC. <strong>Support is limited to formatting strings with them</strong>, hence the qualified name &quot;output calendar&quot;.</p><p>In practice this is pretty useful; you can show users the date in their preferred calendaring system while the software works with dates using Gregorian units or Epoch milliseconds. But the limitations are real enough; Luxon doesn&apos;t know how to do things like &quot;add one Islamic month&quot;.</p><p>The output calendar is a property of the DateTime itself. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">var dtHebrew = DateTime.now().reconfigure({ outputCalendar: &apos;hebrew&apos; });
dtHebrew.outputCalendar; //=&gt; &apos;hebrew&apos;
dtHebrew.toLocaleString() //=&gt; &apos;4 Tishri 5778&apos;</code>
</code></pre><p>You can modulate the structure of that string with arguments to <code>toLocaleString</code> (see <a href="./manual/formatting.html#tolocalestring-strings-for-humans-">the docs on that</a>), but the point here is just that you got the alternative calendar.</p><h3>Generally supported calendars</h3><p>Here&apos;s a table of the different calendars with examples generated formatting the same date generated like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromObject({ outputCalendar: c }).toLocaleString(DateTime.DATE_FULL);</code>
</code></pre><table>
<thead>
<tr>
<th>Calendar</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>buddhist</td>
<td>September 24, 2560 BE</td>
</tr>
<tr>
<td>chinese</td>
<td>Eighth Month 5, 2017</td>
</tr>
<tr>
<td>coptic</td>
<td>Tout 14, 1734 ERA1</td>
</tr>
<tr>
<td>ethioaa</td>
<td>Meskerem 14, 7510 ERA0</td>
</tr>
<tr>
<td>ethiopic</td>
<td>Meskerem 14, 2010 ERA1</td>
</tr>
<tr>
<td>hebrew</td>
<td>4 Tishri 5778</td>
</tr>
<tr>
<td>indian</td>
<td>Asvina 2, 1939 Saka</td>
</tr>
<tr>
<td>islamic</td>
<td>Muharram 4, 1439 AH</td>
</tr>
<tr>
<td>islamicc</td>
<td>Muharram 3, 1439 AH</td>
</tr>
<tr>
<td>japanese</td>
<td>September 24, 29 Heisei</td>
</tr>
<tr>
<td>persian</td>
<td>Mehr 2, 1396 AP</td>
</tr>
<tr>
<td>roc</td>
<td>September 24, 106 Minguo</td>
</tr>
</tbody>
</table><h3>Default output calendar</h3><p>You can set the default output calendar for new DateTime instances like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">Settings.defaultOuputCalendar = &apos;persian&apos;;</code>
</code></pre></div>
        <a data-ice="link" href="manual/calendars.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Formatting</h1><p>This section covers creating strings to represent a DateTime. There are three types of formatting capabilities:</p><ol>
<li>Technical formats like ISO 8601 and RFC 2822</li>
<li>Internationalizable human-readable formats</li>
<li>Token-based formatting</li>
</ol><h2>Technical formats (strings for computers)</h2><h3>ISO 8601</h3><p><a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> is the most widely used set of string formats for dates and times. Luxon can <em>parse</em> a wide range of them, but provides direct support for formatting only a few of them:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.toISO(); //=&gt; &apos;2017-04-20T11:32:00.000-04:00&apos;
dt.toISODate(); //=&gt; &apos;2017-04-20&apos;
dt.toISOWeekDate(); //=&gt; &apos;2017-W17-7&apos;
dt.toISOTime(); //=&gt; &apos;11:32:00.000-04:00&apos;</code>
</code></pre><p>Generally, you&apos;ll want the first one. Use it by default when building or interacting with APIs, communicating times over a wire, etc.</p><h3>HTTP and RFC 2822</h3><p>There are a number of legacy standard date and time formats out there, and Luxon supports some of them. You shouldn&apos;t use them unless you have a specific reason to.</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.toRFC2822(); //=&gt; &apos;Thu, 20 Apr 2017 11:32:00 -0400&apos;
dt.toHTTP(); //=&gt; &apos;Thu, 20 Apr 2017 03:32:00 GMT&apos;</code>
</code></pre><h3>Unix timestamps</h3><p>DateTime objects can also be converted to numerical <a href="https://en.wikipedia.org/wiki/Unix_time">Unix timestamps</a>:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.toMillis(); //=&gt; 1492702320000
dt.toSeconds(); //=&gt; 1492702320
dt.valueOf(); //=&gt; 1492702320000, same as .toMillis()</code>
</code></pre><h2>toLocaleString (strings for humans)</h2><h3>The basics</h3><p>Modern browsers (and other JS environments) provide support for human-readable, internationalized strings. Luxon provides convenient support for them, and you should use them anytime you want to display a time to a user. Use <a href="./manual/../class/src/datetime.js~DateTime.html#instance-method-toLocaleString">toLocaleString</a> to do it:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.toLocaleString(); //=&gt; &apos;4/20/2017&apos;
dt.toLocaleString(DateTime.DATETIME_FULL); //=&gt; &apos;April 20, 2017, 11:32 AM EDT&apos;
dt.setLocale(&quot;fr&quot;).toLocaleString(DateTime.DATETIME_FULL); //=&gt; &apos;20 avril 2017 &#xE0; 11:32 UTC&#x2212;4&apos;</code>
</code></pre><h3>Intl.DateTimeFormat</h3><p>In the example above, <code>DateTime.DATETIME_FULL</code> is one of several convenience formats provided by Luxon. But the arguments are really any object of options that can be provided to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat">Intl.DateTimeFormat</a>. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.toLocaleString({ month: &quot;long&quot;, day: &quot;numeric&quot; }); //=&gt; &apos;April 20&apos;</code>
</code></pre><p>And that&apos;s all the preset is:</p><pre><code><code class="source-code prettyprint">DateTime.DATETIME_FULL;  //=&gt; {
                         //     year: &apos;numeric&apos;,
                         //     month: &apos;long&apos;,
                         //     day: &apos;numeric&apos;,
                         //     hour: &apos;numeric&apos;,
                         //     minute: &apos;2-digit&apos;,
                         //     timeZoneName: &apos;short&apos;
                         //   }</code>
</code></pre><p>This also means you can modify the presets as you choose:</p><pre><code class="lang-js"><code class="source-code prettyprint">dt.toLocaleString(DateTime.DATE_SHORT); //=&gt;  &apos;4/20/2017&apos;
var newFormat = Object.assign(DateTime.DATE_SHORT, { weekday: &quot;long&quot; });
dt.toLocaleString(newFormat); //=&gt;  &apos;Thursday, 4/20/2017&apos;</code>
</code></pre><h3>Presets</h3><p>Here&apos;s the full set of provided presets using the October 14, 1983 at 13:30:23 as an example.</p><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Example in en_US</th>
<th>Example in fr</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATE_SHORT</td>
<td>short date</td>
<td>10/14/1983</td>
<td>14/10/1983</td>
</tr>
<tr>
<td>DATE_MED</td>
<td>abbreviated date</td>
<td>Oct 14, 1983</td>
<td>14 oct. 1983</td>
</tr>
<tr>
<td>DATE_MED_WITH_WEEKDAY</td>
<td>abbreviated date with weekday</td>
<td>Fri, Oct 14, 1983</td>
<td>ven. 14 oct. 1983</td>
</tr>
<tr>
<td>DATE_FULL</td>
<td>full date</td>
<td>October 14, 1983</td>
<td>14 octobre 1983</td>
</tr>
<tr>
<td>DATE_HUGE</td>
<td>full date with weekday</td>
<td>Tuesday, October 14, 1983</td>
<td>vendredi 14 octobre 1983</td>
</tr>
<tr>
<td>TIME_SIMPLE</td>
<td>time</td>
<td>1:30 PM</td>
<td>13:30</td>
</tr>
<tr>
<td>TIME_WITH_SECONDS</td>
<td>time with seconds</td>
<td>1:30:23 PM</td>
<td>13:30:23</td>
</tr>
<tr>
<td>TIME_WITH_SHORT_OFFSET</td>
<td>time with seconds and abbreviated named offset</td>
<td>1:30:23 PM EDT</td>
<td>13:30:23 UTC&#x2212;4</td>
</tr>
<tr>
<td>TIME_WITH_LONG_OFFSET</td>
<td>time with seconds and full named offset</td>
<td>1:30:23 PM Eastern Daylight Time</td>
<td>13:30:23 heure d&#x2019;&#xE9;t&#xE9; de l&#x2019;Est</td>
</tr>
<tr>
<td>TIME_24_SIMPLE</td>
<td>24-hour time</td>
<td>13:30</td>
<td>13:30</td>
</tr>
<tr>
<td>TIME_24_WITH_SECONDS</td>
<td>24-hour time with seconds</td>
<td>13:30:23</td>
<td>13:30:23</td>
</tr>
<tr>
<td>TIME_24_WITH_SHORT_OFFSET</td>
<td>24-hour time with seconds and abbreviated named offset</td>
<td>13:30:23 EDT</td>
<td>13:30:23 UTC&#x2212;4</td>
</tr>
<tr>
<td>TIME_24_WITH_LONG_OFFSET</td>
<td>24-hour time with seconds and full named offset</td>
<td>13:30:23 Eastern Daylight Time</td>
<td>13:30:23 heure d&#x2019;&#xE9;t&#xE9; de l&#x2019;Est</td>
</tr>
<tr>
<td>DATETIME_SHORT</td>
<td>short date &amp; time</td>
<td>10/14/1983, 1:30 PM</td>
<td>14/10/1983 &#xE0; 13:30</td>
</tr>
<tr>
<td>DATETIME_MED</td>
<td>abbreviated date &amp; time</td>
<td>Oct 14, 1983, 1:30 PM</td>
<td>14 oct. 1983 &#xE0; 13:30</td>
</tr>
<tr>
<td>DATETIME_FULL</td>
<td>full date and time with abbreviated named offset</td>
<td>October 14, 1983, 1:30 PM EDT</td>
<td>14 octobre 1983 &#xE0; 13:30 UTC&#x2212;4</td>
</tr>
<tr>
<td>DATETIME_HUGE</td>
<td>full date and time with weekday and full named offset</td>
<td>Friday, October 14, 1983, 1:30 PM Eastern Daylight Time</td>
<td>vendredi 14 octobre 1983 &#xE0; 13:30 heure d&#x2019;&#xE9;t&#xE9; de l&#x2019;Est</td>
</tr>
<tr>
<td>DATETIME_SHORT_WITH_SECONDS</td>
<td>short date &amp; time with seconds</td>
<td>10/14/1983, 1:30:23 PM</td>
<td>14/10/1983 &#xE0; 13:30:23</td>
</tr>
<tr>
<td>DATETIME_MED_WITH_SECONDS</td>
<td>abbreviated date &amp; time with seconds</td>
<td>Oct 14, 1983, 1:30:23 PM</td>
<td>14 oct. 1983 &#xE0; 13:30:23</td>
</tr>
<tr>
<td>DATETIME_FULL_WITH_SECONDS</td>
<td>full date and time with abbreviated named offset with seconds</td>
<td>October 14, 1983, 1:30:23 PM EDT</td>
<td>14 octobre 1983 &#xE0; 13:30:23 UTC&#x2212;4</td>
</tr>
<tr>
<td>DATETIME_HUGE_WITH_SECONDS</td>
<td>full date and time with weekday and full named offset with seconds</td>
<td>Friday, October 14, 1983, 1:30:23 PM Eastern Daylight Time</td>
<td>vendredi 14 octobre 1983 &#xE0; 13:30:23 heure d&#x2019;&#xE9;t&#xE9; de l&#x2019;Est</td>
</tr>
</tbody>
</table><h3>Intl</h3><p><code>toLocaleString</code>&apos;s behavior is affected by the DateTime&apos;s <code>locale</code>, <code>numberingSystem</code>, and <code>outputCalendar</code> properties. See the <a href="./manual/intl.html">Intl</a> section for more.</p><h2>Formatting with tokens (strings for Cthulhu)</h2><p>This section covers generating strings from DateTimes with programmer-specified formats.</p><h3>Consider alternatives</h3><p>You shouldn&apos;t create ad-hoc string formats if you can avoid it. If you intend for a computer to read the string, prefer ISO 8601. If a human will read it, prefer <code>toLocaleString</code>. Both are covered above. However, if you have some esoteric need where you need some specific format (e.g. because some other software expects it), then <code>toFormat</code> is how you do it.</p><h3>toFormat</h3><p>See <a href="./manual/../class/src/datetime.js~DateTime.html#instance-method-toFormat">DateTime#toFormat</a> for the API signature. As a brief motivating example:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromISO(&quot;2014-08-06T13:07:04.054&quot;).toFormat(&quot;yyyy LLL dd&quot;); //=&gt; &apos;2014 Aug 06&apos;</code>
</code></pre><p>The supported tokens are described in the table below.</p><h3>Intl</h3><p>All of the strings (e.g. month names and weekday names) are internationalized by introspecting strings generated by the Intl API. Thus the exact strings you get are implementation-specific.</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromISO(&quot;2014-08-06T13:07:04.054&quot;)
  .setLocale(&quot;fr&quot;)
  .toFormat(&quot;yyyy LLL dd&quot;); //=&gt; &apos;2014 ao&#xFB;t 06&apos;</code>
</code></pre><h3>Escaping</h3><p>You may escape strings using brackets:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.now().toFormat(&quot;HH [hours and] mm [minutes]&quot;); //=&gt; &apos;20 hours and 55 minutes&apos;</code>
</code></pre><h3>Standalone vs format tokens</h3><p>Some tokens have a &quot;standalone&quot; and &quot;format&quot; version. Some languages require different forms of a word based on whether it is part of a longer phrase or just by itself (e.g. &quot;Monday the 22nd&quot; vs &quot;Monday&quot;). Use them accordingly.</p><pre><code class="lang-js"><code class="source-code prettyprint">var d = DateTime.fromISO(&quot;2014-08-06T13:07:04.054&quot;).setLocale(&quot;ru&quot;);
d.toFormat(&quot;LLLL&quot;); //=&gt; &apos;&#x430;&#x432;&#x433;&#x443;&#x441;&#x442;&apos; (standalone)
d.toFormat(&quot;MMMM&quot;); //=&gt; &apos;&#x430;&#x432;&#x433;&#x443;&#x441;&#x442;&#x430;&apos; (format)</code>
</code></pre><h3>Macro tokens</h3><p>Some of the formats are &quot;macros&quot;, meaning they correspond to multiple components. These use the native Intl API and will order their constituent parts in a locale-friendly way.</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromISO(&quot;2014-08-06T13:07:04.054&quot;).toFormat(&quot;ff&quot;); //=&gt; &apos;Aug 6, 2014, 1:07 PM&apos;</code>
</code></pre><p>The macro options available correspond one-to-one with the preset formats defined for <code>toLocaleString</code>.</p><h3>Table of tokens</h3><p>(Examples below given for 2014-08-06T13:07:04.054 considered as a local time in America/New_York).</p><table>
<thead>
<tr>
<th>Standalone token</th>
<th>Format token</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td></td>
<td>millisecond, no padding</td>
<td>54</td>
</tr>
<tr>
<td>SSS</td>
<td></td>
<td>millisecond, padded to 3</td>
<td>054</td>
</tr>
<tr>
<td>u</td>
<td></td>
<td>fractional seconds, functionally identical to SSS</td>
<td>054</td>
</tr>
<tr>
<td>s</td>
<td></td>
<td>second, no padding</td>
<td>4</td>
</tr>
<tr>
<td>ss</td>
<td></td>
<td>second, padded to 2 padding</td>
<td>04</td>
</tr>
<tr>
<td>m</td>
<td></td>
<td>minute, no padding</td>
<td>7</td>
</tr>
<tr>
<td>mm</td>
<td></td>
<td>minute, padded to 2</td>
<td>07</td>
</tr>
<tr>
<td>h</td>
<td></td>
<td>hour in 12-hour time, no padding</td>
<td>1</td>
</tr>
<tr>
<td>hh</td>
<td></td>
<td>hour in 12-hour time, padded to 2</td>
<td>01</td>
</tr>
<tr>
<td>H</td>
<td></td>
<td>hour in 24-hour time, no padding</td>
<td>9</td>
</tr>
<tr>
<td>HH</td>
<td></td>
<td>hour in 24-hour time, padded to 2</td>
<td>13</td>
</tr>
<tr>
<td>Z</td>
<td></td>
<td>narrow offset</td>
<td>+5</td>
</tr>
<tr>
<td>ZZ</td>
<td></td>
<td>short offset</td>
<td>+05:00</td>
</tr>
<tr>
<td>ZZZ</td>
<td></td>
<td>techie offset</td>
<td>+0500</td>
</tr>
<tr>
<td>ZZZZ</td>
<td></td>
<td>abbreviated named offset</td>
<td>EST</td>
</tr>
<tr>
<td>ZZZZZ</td>
<td></td>
<td>unabbreviated named offset</td>
<td>Eastern Standard Time</td>
</tr>
<tr>
<td>z</td>
<td></td>
<td>IANA zone</td>
<td>America/New_York</td>
</tr>
<tr>
<td>a</td>
<td></td>
<td>meridiem</td>
<td>AM</td>
</tr>
<tr>
<td>d</td>
<td></td>
<td>day of the month, no padding</td>
<td>6</td>
</tr>
<tr>
<td>dd</td>
<td></td>
<td>day of the month, padded to 2</td>
<td>06</td>
</tr>
<tr>
<td>c</td>
<td>E</td>
<td>day of the week, as number from 1-7 (Monday is 1, Sunday is 7)</td>
<td>3</td>
</tr>
<tr>
<td>ccc</td>
<td>EEE</td>
<td>day of the week, as an abbreviate localized string</td>
<td>Wed</td>
</tr>
<tr>
<td>cccc</td>
<td>EEEE</td>
<td>day of the week, as an unabbreviated localized string</td>
<td>Wednesday</td>
</tr>
<tr>
<td>ccccc</td>
<td>EEEEE</td>
<td>day of the week, as a single localized letter</td>
<td>W</td>
</tr>
<tr>
<td>L</td>
<td>M</td>
<td>month as an unpadded number</td>
<td>8</td>
</tr>
<tr>
<td>LL</td>
<td>MM</td>
<td>month as an padded number</td>
<td>08</td>
</tr>
<tr>
<td>LLL</td>
<td>MMM</td>
<td>month as an abbreviated localized string</td>
<td>Aug</td>
</tr>
<tr>
<td>LLLL</td>
<td>MMMM</td>
<td>month as an unabbreviated localized string</td>
<td>August</td>
</tr>
<tr>
<td>LLLLL</td>
<td>MMMMM</td>
<td>month as a single localized letter</td>
<td>A</td>
</tr>
<tr>
<td>y</td>
<td></td>
<td>year, unpadded</td>
<td>2014</td>
</tr>
<tr>
<td>yy</td>
<td></td>
<td>two-digit year</td>
<td>14</td>
</tr>
<tr>
<td>yyyy</td>
<td></td>
<td>four- to six- digit year, pads to 4</td>
<td>2014</td>
</tr>
<tr>
<td>G</td>
<td></td>
<td>abbreviated localized era</td>
<td>AD</td>
</tr>
<tr>
<td>GG</td>
<td></td>
<td>unabbreviated localized era</td>
<td>Anno Domini</td>
</tr>
<tr>
<td>GGGGG</td>
<td></td>
<td>one-letter localized era</td>
<td>A</td>
</tr>
<tr>
<td>kk</td>
<td></td>
<td>ISO week year, unpadded</td>
<td>14</td>
</tr>
<tr>
<td>kkkk</td>
<td></td>
<td>ISO week year, padded to 4</td>
<td>2014</td>
</tr>
<tr>
<td>W</td>
<td></td>
<td>ISO week number, unpadded</td>
<td>32</td>
</tr>
<tr>
<td>WW</td>
<td></td>
<td>ISO week number, padded to 2</td>
<td>32</td>
</tr>
<tr>
<td>o</td>
<td></td>
<td>ordinal (day of year), unpadded</td>
<td>218</td>
</tr>
<tr>
<td>ooo</td>
<td></td>
<td>ordinal (day of year), padded to 3</td>
<td>218</td>
</tr>
<tr>
<td>q</td>
<td></td>
<td>quarter, no padding</td>
<td>3</td>
</tr>
<tr>
<td>qq</td>
<td></td>
<td>quarter, padded to 2</td>
<td>03</td>
</tr>
<tr>
<td>D</td>
<td></td>
<td>localized numeric date</td>
<td>9/4/2017</td>
</tr>
<tr>
<td>DD</td>
<td></td>
<td>localized date with abbreviated month</td>
<td>Aug 6, 2014</td>
</tr>
<tr>
<td>DDD</td>
<td></td>
<td>localized date with full month</td>
<td>August 6, 2014</td>
</tr>
<tr>
<td>DDDD</td>
<td></td>
<td>localized date with full month and weekday</td>
<td>Wednesday, August 6, 2014</td>
</tr>
<tr>
<td>t</td>
<td></td>
<td>localized time</td>
<td>9:07 AM</td>
</tr>
<tr>
<td>tt</td>
<td></td>
<td>localized time with seconds</td>
<td>1:07:04 PM</td>
</tr>
<tr>
<td>ttt</td>
<td></td>
<td>localized time with seconds and abbreviated offset</td>
<td>1:07:04 PM EDT</td>
</tr>
<tr>
<td>tttt</td>
<td></td>
<td>localized time with seconds and full offset</td>
<td>1:07:04 PM Eastern Daylight Time</td>
</tr>
<tr>
<td>T</td>
<td></td>
<td>localized 24-hour time</td>
<td>13:07</td>
</tr>
<tr>
<td>TT</td>
<td></td>
<td>localized 24-hour time with seconds</td>
<td>13:07:04</td>
</tr>
<tr>
<td>TTT</td>
<td></td>
<td>localized 24-hour time with seconds and abbreviated offset</td>
<td>13:07:04 EDT</td>
</tr>
<tr>
<td>TTTT</td>
<td></td>
<td>localized 24-hour time with seconds and full offset</td>
<td>13:07:04 Eastern Daylight Time</td>
</tr>
<tr>
<td>f</td>
<td></td>
<td>short localized date and time</td>
<td>8/6/2014, 1:07 PM</td>
</tr>
<tr>
<td>ff</td>
<td></td>
<td>less short localized date and time</td>
<td>Aug 6, 2014, 1:07 PM</td>
</tr>
<tr>
<td>fff</td>
<td></td>
<td>verbose localized date and time</td>
<td>August 6, 2014, 1:07 PM EDT</td>
</tr>
<tr>
<td>ffff</td>
<td></td>
<td>extra verbose localized date and time</td>
<td>Wednesday, August 6, 2014, 1:07 PM Eastern Daylight Time</td>
</tr>
<tr>
<td>F</td>
<td></td>
<td>short localized date and time with seconds</td>
<td>8/6/2014, 1:07:04 PM</td>
</tr>
<tr>
<td>FF</td>
<td></td>
<td>less short localized date and time with seconds</td>
<td>Aug 6, 2014, 1:07:04 PM</td>
</tr>
<tr>
<td>FFF</td>
<td></td>
<td>verbose localized date and time with seconds</td>
<td>August 6, 2014, 1:07:04 PM EDT</td>
</tr>
<tr>
<td>FFFF</td>
<td></td>
<td>extra verbose localized date and time with seconds</td>
<td>Wednesday, August 6, 2014, 1:07:04 PM Eastern Daylight Time</td>
</tr>
<tr>
<td>X</td>
<td></td>
<td>unix timestamp in seconds</td>
<td>1407287224</td>
</tr>
<tr>
<td>x</td>
<td></td>
<td>unix timestamp in milliseconds</td>
<td>1407287224054</td>
</tr>
</tbody>
</table></div>
        <a data-ice="link" href="manual/formatting.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Parsing</h1><p>Luxon is not an NLP tool and isn&apos;t suitable for all date parsing jobs. But it can do some parsing:</p><ol>
<li>Direct support for several well-known formats, including most valid ISO 8601 formats</li>
<li>An ad-hoc parser for parsing specific formats</li>
</ol><h2>Parsing technical formats</h2><h3>ISO 8601</h3><p>Luxon supports a wide range of valid ISO 8601 formats through the <a href="./manual/../class/src/datetime.js~DateTime.html#static-method-fromISO">fromISO</a> method.</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromISO(&quot;2016-05-25&quot;);</code>
</code></pre><p>All of these are parsable by <code>fromISO</code>:</p><pre><code><code class="source-code prettyprint">2016
2016-05
201605
2016-05-25
20160525
2016-05-25T09
2016-05-25T09:24
2016-05-25T09:24:15
2016-05-25T09:24:15.123
2016-05-25T0924
2016-05-25T092415
2016-05-25T092415.123
2016-05-25T09:24:15,123
2016-W21-3
2016W213
2016-W21-3T09:24:15.123
2016W213T09:24:15.123
2016-200
2016200
2016-200T09:24:15.123
09:24
09:24:15
09:24:15.123
09:24:15,123</code>
</code></pre><ul>
<li>In addition, all the times support offset arguments like &quot;Z&quot; and &quot;+06:00&quot;.</li>
<li>Missing lower-order values are always set to the minimum possible value; i.e. it always parses to a full DateTime. For example, &quot;2016-05-25&quot; parses to midnight of that day. &quot;2016-05&quot; parses to the first of the month, etc.</li>
<li>The time is parsed as a local time if no offset is specified, but see the method docs to see your options, and also check out <a href="./manual/zones.html">time zone docs</a> for more details.</li>
</ul><h3>HTTP and RFC2822</h3><p>Luxon also provides parsing for strings formatted according to RFC 2822 and the HTTP header specs (RFC 850 and 1123):</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromRFC2822(&quot;Tue, 01 Nov 2016 13:23:12 +0630&quot;);
DateTime.fromHTTP(&quot;Sunday, 06-Nov-94 08:49:37 GMT&quot;);
DateTime.fromHTTP(&quot;Sun, 06 Nov 1994 08:49:37 GMT&quot;);</code>
</code></pre><h3>SQL</h3><p>Luxon accepts SQL dates, times, and datetimes, via <a href="./manual/../class/src/datetime.js~DateTime.html#static-method-fromSQL">fromSQL</a>:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromSQL(&quot;2017-05-15&quot;);
DateTime.fromSQL(&quot;2017-05-15 09:24:15&quot;);
DateTime.fromSQL(&quot;09:24:15&quot;);</code>
</code></pre><p>It works similarly to <code>fromISO</code>, so see above for additional notes.</p><h3>Unix timestamps</h3><p>Luxon can parse numerical <a href="https://en.wikipedia.org/wiki/Unix_time">Unix timestamps</a>:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromMillis(1542674993410);
DateTime.fromSeconds(1542674993);</code>
</code></pre><p>Both methods accept the same options, which allow you to specify a timezone, calendar, and/or numbering system.</p><h2>Ad-hoc parsing</h2><h3>Consider alternatives</h3><p>You generally shouldn&apos;t use Luxon to parse arbitrarily formatted date strings:</p><ol>
<li>If the string was generated by a computer for programmatic access, use a standard format like ISO 8601. Then you can parse it using <a href="./manual/../class/src/datetime.js~DateTime.html#static-method-fromISO">DateTime.fromISO</a>.</li>
<li>If the string is typed out by a human, it may not conform to the format you specify when asking Luxon to parse it. Luxon is quite strict about the format matching the string exactly.</li>
</ol><p>Sometimes, though, you get a string from some legacy system in some terrible ad-hoc format and you need to parse it.</p><h3>fromFormat</h3><p>See <a href="./manual/../class/src/datetime.js~DateTime.html#static-method-fromFormat">DateTime.fromFormat</a> for the method signature. A brief example:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromFormat(&quot;May 25 1982&quot;, &quot;LLLL dd yyyy&quot;);</code>
</code></pre><h3>Intl</h3><p>Luxon supports parsing internationalized strings:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromFormat(&quot;mai 25 1982&quot;, &quot;LLLL dd yyyy&quot;, { locale: &quot;fr&quot; });</code>
</code></pre><p>Note, however, that Luxon derives the list of strings that can match, say, &quot;LLLL&quot; (and their meaning) by introspecting the environment&apos;s Intl implementation. Thus the exact strings may in some cases be environment-specific. You also need the Intl API available on the target platform (see the <a href="./manual/matrix.html">support matrix</a>).</p><h3>Limitations</h3><p>Not every token supported by <code>DateTime#toFormat</code> is supported in the parser. For example, there&apos;s no <code>ZZZZ</code> or <code>ZZZZZ</code> tokens. This is for a few reasons:</p><ul>
<li>Luxon relies on natively-available functionality that only provides the mapping in one direction. We can ask what the named offset is and get &quot;Eastern Standard Time&quot; but not ask what &quot;Eastern Standard Time&quot; is most likely to mean.</li>
<li>Some things are ambiguous. There are several Eastern Standard Times in different countries and Luxon has no way to know which one you mean without additional information (such as that the zone is America/New_York) that would make EST superfluous anyway. Similarly, the single-letter month and weekday formats (EEEEE) that are useful in displaying calendars graphically can&apos;t be parsed because of their ambiguity.</li>
<li>Because of the limitations above, Luxon also doesn&apos;t support the &quot;macro&quot; tokens that include offset names, such ass &quot;ttt&quot; and &quot;FFFF&quot;.</li>
</ul><h3>Debugging</h3><p>There are two kinds of things that can go wrong when parsing a string: a) you make a mistake with the tokens or b) the information parsed from the string does not correspond to a valid date. To help you sort that out, Luxon provides a method called <a href="./manual/../class/src/datetime.js~DateTime.html#static-method-fromFormatExplain">fromFormatExplain</a>. It takes the same arguments as <code>fromFormat</code> but returns a map of information about the parse that can be useful in debugging.</p><p>For example, here the code is using &quot;MMMM&quot; where &quot;MMM&quot; was needed. You can see the regex Luxon uses and see that it didn&apos;t match anything:</p><pre><code class="lang-js"><code class="source-code prettyprint">&gt; DateTime.fromFormatExplain(&quot;Aug 6 1982&quot;, &quot;MMMM d yyyy&quot;)

{ input: &apos;Aug 6 1982&apos;,
  tokens:
   [ { literal: false, val: &apos;MMMM&apos; },
     { literal: false, val: &apos; &apos; },
     { literal: false, val: &apos;d&apos; },
     { literal: false, val: &apos; &apos; },
     { literal: false, val: &apos;yyyy&apos; } ],
  regex: &apos;(January|February|March|April|May|June|July|August|September|October|November|December)( )(\\d\\d?)( )(\\d{4})&apos;,
  matches: {},
  result: {},
  zone: null }</code>
</code></pre><p>If you parse something and get an invalid date, the debugging steps are slightly different. Here, we&apos;re attempting to parse August 32nd, which doesn&apos;t exist:</p><pre><code class="lang-js"><code class="source-code prettyprint">var d = DateTime.fromFormat(&quot;August 32 1982&quot;, &quot;MMMM d yyyy&quot;);
d.isValid; //=&gt; false
d.invalidReason; //=&gt; &apos;day out of range&apos;</code>
</code></pre><p>For more on validity and how to debug it, see <a href="./manual/errors.html">errors</a>. You may find more comprehensive tips there. But as it applies specifically to <code>fromFormat</code>, again try <code>fromFormatExplain</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">&gt; DateTime.fromFormatExplain(&quot;August 32 1982&quot;, &quot;MMMM d yyyy&quot;)

{ input: &apos;August 32 1982&apos;,
  tokens:
   [ { literal: false, val: &apos;MMMM&apos; },
     { literal: false, val: &apos; &apos; },
     { literal: false, val: &apos;d&apos; },
     { literal: false, val: &apos; &apos; },
     { literal: false, val: &apos;yyyy&apos; } ],
  regex: &apos;(January|February|March|April|May|June|July|August|September|October|November|December)( )(\\d\\d?)( )(\\d{4})&apos;,
  matches: { M: 8, d: 32, y: 1982 },
  result: { month: 8, day: 32, year: 1982 },
  zone: null }</code>
</code></pre><p>Because Luxon was able to parse the string without difficulty, the output is a lot richer. And you can see that the &quot;day&quot; field is set to 32. Combined with the &quot;out of range&quot; explanation above, that should clear up the situation.</p><h3>Table of tokens</h3><p>(Examples below given for 2014-08-06T13:07:04.054 considered as a local time in America/New_York). Note that many tokens supported by the <a href="./manual/formatting.md">formatter</a> are <strong>not</strong> supported by the parser. That includes all the &quot;macro&quot; formats like &quot;D&quot; for &quot;localized numeric date&quot;.</p><table>
<thead>
<tr>
<th>Standalone token</th>
<th>Format token</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td></td>
<td>millisecond, no padding</td>
<td>54</td>
</tr>
<tr>
<td>SSS</td>
<td></td>
<td>millisecond, padded to 3</td>
<td>054</td>
</tr>
<tr>
<td>u</td>
<td></td>
<td>fractional seconds, (5 is a half second, 54 is slightly more)</td>
<td>54</td>
</tr>
<tr>
<td>s</td>
<td></td>
<td>second, no padding</td>
<td>4</td>
</tr>
<tr>
<td>ss</td>
<td></td>
<td>second, padded to 2 padding</td>
<td>04</td>
</tr>
<tr>
<td>m</td>
<td></td>
<td>minute, no padding</td>
<td>7</td>
</tr>
<tr>
<td>mm</td>
<td></td>
<td>minute, padded to 2</td>
<td>07</td>
</tr>
<tr>
<td>h</td>
<td></td>
<td>hour in 12-hour time, no padding</td>
<td>1</td>
</tr>
<tr>
<td>hh</td>
<td></td>
<td>hour in 12-hour time, padded to 2</td>
<td>01</td>
</tr>
<tr>
<td>H</td>
<td></td>
<td>hour in 24-hour time, no padding</td>
<td>9</td>
</tr>
<tr>
<td>HH</td>
<td></td>
<td>hour in 24-hour time, padded to 2</td>
<td>13</td>
</tr>
<tr>
<td>Z</td>
<td></td>
<td>narrow offset</td>
<td>+5</td>
</tr>
<tr>
<td>ZZ</td>
<td></td>
<td>short offset</td>
<td>+05:00</td>
</tr>
<tr>
<td>ZZZ</td>
<td></td>
<td>techie offset</td>
<td>+0500</td>
</tr>
<tr>
<td>z</td>
<td></td>
<td>IANA zone</td>
<td>America/New_York</td>
</tr>
<tr>
<td>a</td>
<td></td>
<td>meridiem</td>
<td>AM</td>
</tr>
<tr>
<td>d</td>
<td></td>
<td>day of the month, no padding</td>
<td>6</td>
</tr>
<tr>
<td>dd</td>
<td></td>
<td>day of the month, padded to 2</td>
<td>06</td>
</tr>
<tr>
<td>E</td>
<td>c</td>
<td>day of the week, as number from 1-7 (Monday is 1, Sunday is 7)</td>
<td>3</td>
</tr>
<tr>
<td>EEE</td>
<td>ccc</td>
<td>day of the week, as an abbreviate localized string</td>
<td>Wed</td>
</tr>
<tr>
<td>EEEE</td>
<td>cccc</td>
<td>day of the week, as an unabbreviated localized string</td>
<td>Wednesday</td>
</tr>
<tr>
<td>M</td>
<td>L</td>
<td>month as an unpadded number</td>
<td>8</td>
</tr>
<tr>
<td>MM</td>
<td>LL</td>
<td>month as an padded number</td>
<td>08</td>
</tr>
<tr>
<td>MMM</td>
<td>LLL</td>
<td>month as an abbreviated localized string</td>
<td>Aug</td>
</tr>
<tr>
<td>MMMM</td>
<td>LLLL</td>
<td>month as an unabbreviated localized string</td>
<td>August</td>
</tr>
<tr>
<td>y</td>
<td></td>
<td>year, 1-6 digits, very literally</td>
<td>2014</td>
</tr>
<tr>
<td>yy</td>
<td></td>
<td>two-digit year, interpreted as &gt; 1960 (also accepts 4)</td>
<td>14</td>
</tr>
<tr>
<td>yyyy</td>
<td></td>
<td>four-digit year</td>
<td>2014</td>
</tr>
<tr>
<td>yyyyy</td>
<td></td>
<td>four- to six-digit years</td>
<td>10340</td>
</tr>
<tr>
<td>yyyyyy</td>
<td></td>
<td>six-digit years</td>
<td>010340</td>
</tr>
<tr>
<td>G</td>
<td></td>
<td>abbreviated localized era</td>
<td>AD</td>
</tr>
<tr>
<td>GG</td>
<td></td>
<td>unabbreviated localized era</td>
<td>Anno Domini</td>
</tr>
<tr>
<td>GGGGG</td>
<td></td>
<td>one-letter localized era</td>
<td>A</td>
</tr>
<tr>
<td>kk</td>
<td></td>
<td>ISO week year, unpadded</td>
<td>17</td>
</tr>
<tr>
<td>kkkk</td>
<td></td>
<td>ISO week year, padded to 4</td>
<td>2014</td>
</tr>
<tr>
<td>W</td>
<td></td>
<td>ISO week number, unpadded</td>
<td>32</td>
</tr>
<tr>
<td>WW</td>
<td></td>
<td>ISO week number, padded to 2</td>
<td>32</td>
</tr>
<tr>
<td>o</td>
<td></td>
<td>ordinal (day of year), unpadded</td>
<td>218</td>
</tr>
<tr>
<td>ooo</td>
<td></td>
<td>ordinal (day of year), padded to 3</td>
<td>218</td>
</tr>
<tr>
<td>q</td>
<td></td>
<td>quarter, no padding</td>
<td>3</td>
</tr>
<tr>
<td>D</td>
<td></td>
<td>localized numeric date</td>
<td>9/4/2017</td>
</tr>
<tr>
<td>DD</td>
<td></td>
<td>localized date with abbreviated month</td>
<td>Aug 6, 2014</td>
</tr>
<tr>
<td>DDD</td>
<td></td>
<td>localized date with full month</td>
<td>August 6, 2014</td>
</tr>
<tr>
<td>DDDD</td>
<td></td>
<td>localized date with full month and weekday</td>
<td>Wednesday, August 6, 2014</td>
</tr>
<tr>
<td>t</td>
<td></td>
<td>localized time</td>
<td>9:07 AM</td>
</tr>
<tr>
<td>tt</td>
<td></td>
<td>localized time with seconds</td>
<td>1:07:04 PM</td>
</tr>
<tr>
<td>T</td>
<td></td>
<td>localized 24-hour time</td>
<td>13:07</td>
</tr>
<tr>
<td>TT</td>
<td></td>
<td>localized 24-hour time with seconds</td>
<td>13:07:04</td>
</tr>
<tr>
<td>TTT</td>
<td></td>
<td>localized 24-hour time with seconds and abbreviated offset</td>
<td>13:07:04 EDT</td>
</tr>
<tr>
<td>f</td>
<td></td>
<td>short localized date and time</td>
<td>8/6/2014, 1:07 PM</td>
</tr>
<tr>
<td>ff</td>
<td></td>
<td>less short localized date and time</td>
<td>Aug 6, 2014, 1:07 PM</td>
</tr>
<tr>
<td>F</td>
<td></td>
<td>short localized date and time with seconds</td>
<td>8/6/2014, 1:07:04 PM</td>
</tr>
<tr>
<td>FF</td>
<td></td>
<td>less short localized date and time with seconds</td>
<td>Aug 6, 2014, 1:07:04 PM</td>
</tr>
</tbody>
</table></div>
        <a data-ice="link" href="manual/parsing.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Math</h1><p>This page covers some oddball topics related to date and time math, which has some quirky corner cases.</p><h2>Calendar math vs time math</h2><h3>The basics</h3><p>Math with dates and times can be unintuitive to programmers. If it&apos;s Feb 13, 2017 and I say &quot;in exactly one month&quot;, you know I mean March 13. Exactly one month after that is April 13. But because February is a shorter month than March, that means we added a different amount of time in each case. On the other hand, if I said &quot;30 days from February 13&quot;, you&apos;d try to figure out what day that landed on in March. Here it is in Luxon:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.local(2017, 2, 13).plus({ months: 1 }).toISODate() //=&gt; &apos;2017-03-13&apos;

DateTime.local(2017, 2, 13).plus({ days: 30 }).toISODate() //=&gt; &apos;2017-03-15&apos;</code>
</code></pre><p>More generally we can differentiate two modes of math:</p><ul>
<li>Calendar math works with higher-order, variable-length units like years and months</li>
<li>Time math works with lower-order, constant-length units such as hours, minutes, and seconds.</li>
</ul><h3>Which units use which math?</h3><p>These units use calendar math:</p><ul>
<li><strong>Years</strong> vary because of leap years.</li>
<li><strong>Months</strong> vary because they&apos;re just different lengths.</li>
<li><strong>Days</strong> vary because DST transitions mean some days are 23 or 25 hours long.</li>
<li><strong>Quarters</strong> are always three months, but months vary in length so quarters do too.</li>
<li><strong>Weeks</strong> are always the same number of days, but days vary so weeks do too.</li>
</ul><p>These units use time math:</p><ul>
<li><strong>Hours</strong> are always 60 minutes</li>
<li><strong>Minutes</strong> are always 60 seconds</li>
<li><strong>Seconds</strong> are always 1000 milliseconds</li>
</ul><p>Don&apos;t worry about leap seconds. Javascript and most other programming environments don&apos;t account for them; they just happen as abrupt, invisible changes to the underlying system&apos;s time.</p><h3>How to think about calendar math</h3><p>It&apos;s best not to think of calendar math as requiring arcane checks on the lengths of intervening periods. Instead, think of them as <strong>adjusting that unit directly and keeping lower order date components constant</strong>. Let&apos;s go back to the Feb 13 + 1 month example. If you didn&apos;t have Luxon, you would do something like this to accomplish that:</p><pre><code class="lang-js"><code class="source-code prettyprint">var d = new Date(&apos;2017-02-13&apos;)
d.setMonth(d.getMonth() + 1)
d.toLocaleString() //=&gt; &apos;3/13/2017, 12:00:00 AM&apos;</code>
</code></pre><p>And under the covers, that&apos;s more or less what Luxon does too. It doesn&apos;t boil the operation down to a milliseconds delta because that&apos;s not what&apos;s being asked. Instead, it fiddles with what it thinks the date should be and then uses the built-in Gregorian calendar to compute the new timestamp.</p><h3>DSTs</h3><p>There&apos;s a whole section about this in the <a href="./manual/zones.html#math-across-dsts">time zones documentation</a>. But here&apos;s a quick example (Spring Forward is early on March 12 in my time zone):</p><pre><code><code class="source-code prettyprint">var start = DateTime.local(2017, 3, 11, 10);
start.hour                          //=&gt; 10, just for comparison
start.plus({days: 1}).hour          //=&gt; 10, stayed the same
start.plus({hours: 24}).hour        //=&gt; 11, DST pushed forward an hour</code>
</code></pre><p>So in adding a day, we kept the hour at 10, even though that&apos;s only 23 hours later.</p><h3>Time math</h3><p>Time math is different. In time math, we&apos;re just adjusting the clock, adding or subtracting from the epoch timestamp. Adding 63 hours is really the same as adding 63 hours&apos; worth of milliseconds. Under the covers, Luxon does this exactly the opposite of how it does calendar math; it boils the operation down to milliseconds, computes the new timestamp, and then computes the date out of that.</p><h2>Math with multiple units</h2><p>It&apos;s possible to do math with multiple units:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromISO(&apos;2017-05-15&apos;).plus({months: 2, days: 6}).toISODate(); //=&gt; &apos;2017-07-21&apos;</code>
</code></pre><p>This isn&apos;t as simple as it looks. For example, what should you expect this to do?</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromISO(&apos;2017-04-30&apos;).plus({months: 1, days: 1}).toISODate();</code>
</code></pre><p>If the day is added first, we&apos;ll get an intermediate value of May 1. Adding a month to that gives us June 1. But if the month is added first, we&apos;ll an intermediate value of May 30 and day after that is May 31. (See &quot;Calendar math vs time math above if this is confusing.) So the order matters.</p><p>Luxon has a simple rule for this: <strong>math is done from highest order to lowest order</strong>. So the result of the example above is May 31. This rule isn&apos;t logically necessary, but it does seem reflect what people mean. Of course, Luxon can&apos;t enforce this rule if you do the math in separate operations:</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.fromISO(&apos;2017-04-30&apos;).plus({days: 1}).plus({months: 1}).toISODate() //=&gt; &apos;2017-06-01&apos;</code>
</code></pre><p>It&apos;s not a coincidence that Luxon&apos;s interface makes it awkward to do this wrong.</p><h2>Comparing DateTimes</h2><p>DateTime implements <code>#valueOf</code> to return the epoch timestamp, so you can compare DateTimes with <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>. That lets you find out if one DateTime is after or before another DateTime.</p><pre><code class="lang-js"><code class="source-code prettyprint">d1 &lt; d2 // is d1 before d2?</code>
</code></pre><p>However, be aware that <code>===</code> compares object identity, which is not a useful concept in a library with immutable types. Use <code>#equals</code> to compare both the time and additional metadata, such as the locale and time zone. If you&apos;re only interested in checking the equality of the timestamps, you can use:</p><pre><code class="lang-js"><code class="source-code prettyprint">d1.toMillis() === d2.toMillis() // are d1 and d2 the same instant in time?
+d1 === +d2 // same test, using object coercion</code>
</code></pre><p>You may also use <code>#hasSame</code> to make more subtle comparisons:</p><pre><code class="lang-js"><code class="source-code prettyprint">d1.hasSame(d2, &apos;millisecond&apos;); // equivalent to `+d1 === +d2`
d1.hasSame(d2, &apos;minute&apos;);       // both DateTimes are in the same minute (and hour, day, month, etc)
d1.hasSame(d2, &apos;year&apos;);         // etc</code>
</code></pre><p>Note that these are checking against the calendar. For example, if <code>d1</code> is in 2017, calling <code>hasSame</code> with &quot;year&quot; asks if d2 is also in 2017, not whether the DateTimes within a year of each other. For that, you&apos;d need <code>diff</code> (see below).</p><p>If you&apos;d like to compare using a specific unit, you can achieve this by combining <code>#startOf</code> and the <code>#valueOf</code> comparisons above.</p><pre><code class="lang-js"><code class="source-code prettyprint">var d1 = DateTime.fromISO(&apos;2017-04-30&apos;);
var d2 = DateTime.fromISO(&apos;2017-04-01&apos;);

d2 &lt; d1                                   //=&gt; true
d2.startOf(&apos;year&apos;) &lt; d1.startOf(&apos;year&apos;)   //=&gt; false
d2.startOf(&apos;month&apos;) &lt; d1.startOf(&apos;month&apos;) //=&gt; false
d2.startOf(&apos;day&apos;) &lt; d1.startOf(&apos;day&apos;)     //=&gt; true</code>
</code></pre><h2>Duration math</h2><h3>Basics</h3><p><a href="./manual/../class/src/duration.js~Duration.html">Durations</a> are quantities of time, like &quot;3 days and 6 hours&quot;. Luxon has no idea <em>which</em> 3 days and 6 hours they represent; it&apos;s just how Luxon represents those quantities in abstract, unmoored from the timeline. This is both tremendously useful and occasionally confusing. I&apos;m not going to give a detailed tour of their capabilities here (see the API docs for that), but I do want to clear up some of those confusions.</p><p>Here&apos;s some very basic stuff to get us going:</p><pre><code class="lang-js"><code class="source-code prettyprint">var dur = Duration.fromObject({ days: 3, hours: 6})

// examine it
dur.toObject()          //=&gt; { days: 3, hours: 6 }

// express in minutes
dur.as(&apos;minutes&apos;)       //=&gt; 4680

// convert to minutes
dur.shiftTo(&apos;minutes&apos;).toObject() //=&gt; { minutes: 4680 }

// add to a DateTime
DateTime.fromISO(&quot;2017-05-15&quot;).plus(dur).toISO() //=&gt; &apos;2017-05-18T06:00:00.000-04:00&apos;</code>
</code></pre><h3>Diffs</h3><p>You can subtract one time from another to find out how much time there is between them. Luxon&apos;s <a href="./manual/../class/src/datetime.js~DateTime.html#instance-method-diff">diff</a> method does this and it returns a Duration. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">var end = DateTime.fromISO(&apos;2017-03-13&apos;);
var start = DateTime.fromISO(&apos;2017-02-13&apos;);

var diffInMonths = end.diff(start, &apos;months&apos;);
diffInMonths.toObject(); //=&gt; { months: 1 }</code>
</code></pre><p>Notice we had to pick the unit to keep track of the diff in. The default is milliseconds:</p><pre><code class="lang-js"><code class="source-code prettyprint">var diff = end.diff(start);
diff.toObject() //=&gt; { milliseconds: 2415600000 }</code>
</code></pre><p>Finally, you can diff using multiple units:</p><pre><code class="lang-js"><code class="source-code prettyprint">var end = DateTime.fromISO(&apos;2017-03-13&apos;);
var start = DateTime.fromISO(&apos;2017-02-15&apos;);
end.diff(start, [&apos;months&apos;, &apos;days&apos;]) //=&gt; { months: 1, days: 2 }</code>
</code></pre><h3>Casual vs longterm conversion accuracy</h3><p>Durations represent bundles of time with specific units, but Luxon allows you to convert between them:</p><ul>
<li><code>shiftTo</code> returns a new Duration denominated in the specified units.</li>
<li><code>as</code> converts the duration to just that unit and returns its value</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">var dur = Duration.fromObject({ months: 4, weeks: 2, days: 6 })

dur.as(&apos;days&apos;)                            //=&gt; 140
dur.shiftTo(&apos;days&apos;).toObject()            //=&gt; { days: 140 }
dur.shiftTo(&apos;weeks&apos;, &apos;hours&apos;).toObject()  //=&gt; { weeks: 18, hours: 144 }</code>
</code></pre><p>But how do those conversions actually work? First, uncontroversially:</p><ul>
<li>1 week = 7 days</li>
<li>1 day = 24 hours</li>
<li>1 hour = 60 minutes</li>
<li>1 minute = 60 seconds</li>
<li>1 second = 1000 milliseconds</li>
</ul><p>These are always true and you can roll them up and down with consistency (e.g. <code>1 hour = 60 * 60 * 1000 milliseconds</code>). However, this isn&apos;t really true for the higher order units, which vary in length, even putting DSTs aside. A year is sometimes 365 days long and sometimes 366. Months are 28, 29, 30, or 31 days. By default Luxon converts between these units using what you might call &quot;casual&quot; conversions:</p><table>
<thead>
<tr>
<th></th>
<th>Month</th>
<th>Week</th>
<th>Day</th>
</tr>
</thead>
<tbody>
<tr>
<td>Year</td>
<td>12</td>
<td>52</td>
<td>365</td>
</tr>
<tr>
<td>Quarter</td>
<td>3</td>
<td>13</td>
<td>91</td>
</tr>
<tr>
<td>Month</td>
<td></td>
<td>4</td>
<td>30</td>
</tr>
</tbody>
</table><p>These should match your intuition and for most purposes they work well. But they&apos;re not just wrong; they&apos;re not even self-consistent:</p><pre><code class="lang-js"><code class="source-code prettyprint">dur.shiftTo(&apos;months&apos;).shiftTo(&apos;days&apos;).as(&apos;years&apos;) //=&gt; 0.9863013698630136</code>
</code></pre><p>This is because 12 * 30 != 365. These errors can be annoying, but they can also cause significant issues if the errors accumulate:</p><pre><code class="lang-js"><code class="source-code prettyprint">var dur = Duration.fromObject({ years: 50000 });
DateTime.now().plus(dur.shiftTo(&apos;milliseconds&apos;)).year //=&gt; 51984
DateTime.now().plus(dur).year                         //=&gt; 52017</code>
</code></pre><p>Those are 33 years apart! So Luxon offers an alternative conversion scheme called &quot;longterm&quot;, based on the 400-year calendar cycle:</p><table>
<thead>
<tr>
<th></th>
<th>Month</th>
<th>Week</th>
<th>Day</th>
</tr>
</thead>
<tbody>
<tr>
<td>Year</td>
<td>12</td>
<td>52.1775</td>
<td>365.2425</td>
</tr>
<tr>
<td>Quarter</td>
<td>3</td>
<td>13.04435</td>
<td>91.310625</td>
</tr>
<tr>
<td>Month</td>
<td></td>
<td>4.348125</td>
<td>30.436875</td>
</tr>
</tbody>
</table><p>You can see why these are irritating to work with, which is why they&apos;re not the default.</p><p>Luxon methods that create Durations de novo accept an option called <code>conversionAccuracy</code>. You can set it to &quot;casual&quot; or &quot;longterm&quot;. It&apos;s a property of the Duration itself, so any conversions you do use the rule you&apos;ve picked, and any new Durations you derive from it will retain that property.</p><pre><code class="lang-js"><code class="source-code prettyprint">Duration.fromObject({ years: 23, conversionAccuracy: &apos;longterm&apos; });
Duration.fromISO(&apos;PY23&apos;, { conversionAccuracy: &apos;longterm&apos; });

end.diff(start, &apos;days&apos;, { conversionAccuracy: &apos;longterm&apos; })</code>
</code></pre><p>You can also create an accurate Duration out of an existing one:</p><pre><code class="lang-js"><code class="source-code prettyprint">var pedanticDuration = casualDuration.reconfigure({ conversionAccuracy: &apos;longterm&apos; });</code>
</code></pre><p>These Durations will do their conversions differently.</p><h3>Losing information</h3><p>Be careful of converting between units. It&apos;s easy to lose information. Let&apos;s say we converted a diff into days:</p><pre><code class="lang-js"><code class="source-code prettyprint">var end = DateTime.fromISO(&apos;2017-03-13&apos;);
var start = DateTime.fromISO(&apos;2017-02-13&apos;);

var diffInMonths = end.diff(start, &apos;months&apos;);
diffInMonths.as(&apos;days&apos;); //=&gt; 30</code>
</code></pre><p>That&apos;s our conversion between months and days (you could also do a longterm-accurate conversion; it wouldn&apos;t fix the issue ahead). But this isn&apos;t the number of days between February 15 and March 15!</p><pre><code class="lang-js"><code class="source-code prettyprint">var diffInDays = end.diff(start, &apos;days&apos;);
diffInDays.toObject(); //=&gt; { days: 28 }</code>
</code></pre><p>It&apos;s important to remember that diffs are Duration objects, and a Duration is just a dumb pile of time units our computation spat out. Unlike an Interval, a Duration doesn&apos;t &quot;remember&quot; what the inputs to the diff were. So we lost some information converting between units. This mistake is really common when rolling up:</p><pre><code class="lang-js"><code class="source-code prettyprint">var diff = end.diff(start); // default unit is milliseconds

// wtf, that&apos;s not a month!
diff.as(&apos;months&apos;); //=&gt; 0.9319444 

// it&apos;s not even the right number of days! (hint: my time zone has a DST)
diff.shiftTo(&apos;hours&apos;).as(&apos;days&apos;); //=&gt; 27.958333333333332</code>
</code></pre><p>Normally you won&apos;t run into this problem if you think clearly about what you want to do with a diff. Specifically, make sure you diff in the units you actually want to use. Then Luxon knows to answer the question you really want to ask.</p><pre><code class="lang-js"><code class="source-code prettyprint">var monthsDiff = end.diff(start, &quot;months&quot;);
var daysDiff = end.diff(start, &quot;days&quot;);</code>
</code></pre><p>But sometimes you really do want an object that represents the subtraction itself, not the result. <a href="./manual/../class/src/interval.js~Interval.html">Intervals</a> can help. Intervals are mostly used to keep track of ranges of time, but they make for &quot;anchored&quot; diffs too. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">var end = DateTime.fromISO(&apos;2017-03-13&apos;);
var start = DateTime.fromISO(&apos;2017-02-13&apos;);
var i = Interval.fromDateTimes(start, end);

i.length(&apos;days&apos;);       //=&gt; 28
i.length(&apos;months&apos;)      //=&gt; 1</code>
</code></pre><p>Because the Interval stores its endpoints and computes <code>length</code> on the fly, it retakes the diff each time you query it. Of course, precisely because an Interval <em>isn&apos;t</em> an abstract bundle of time, it can&apos;t be used in places where Durations can. For example, you can&apos;t add them to DateTime via <code>plus()</code> because Luxon wouldn&apos;t know what units to do the math in (see &quot;Calendar vs time math&quot; above). But you can convert the interval into a Duration by picking the units:</p><pre><code class="lang-js"><code class="source-code prettyprint">i.toDuration(&apos;months&apos;).toObject(); //=&gt; { months: 1 }
i.toDuration(&apos;days&apos;).toObject(); //=&gt; { days: 28 }</code>
</code></pre><p>You can even pick multiple units:</p><pre><code class="lang-js"><code class="source-code prettyprint">end = DateTime.fromISO(&apos;2018-05-25&apos;);
i = start.until(end);
i.toDuration([&apos;years&apos;, &apos;months&apos;, &apos;days&apos;]).toObject(); //=&gt; { years: 1, months: 3, days: 12 }</code>
</code></pre><p>Of course, once you&apos;ve converted to a Duration, you&apos;re back in the same spot you were with the diff case; <em>further</em> conversions will be lossy. So the point is to think carefully about what information you have when.</p></div>
        <a data-ice="link" href="manual/math.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Errors</h1><p>Sometimes Luxon throws errors. Here&apos;s a rundown on when and why.</p><h2>InvalidUnitError</h2><h2>UnitOutOfRangeError</h2><h2>InvalidZoneError</h2><h2>MissingPlatformFeatureError</h2><h2>ConflictingSpecificationError</h2><h2>InvalidArgumentError</h2><p>The most important error is the <code>InvalidDateTime</code> error. One of the most irritating aspects of programming with time is that it&apos;s possible to end up with invalid dates. This is a bit subtle: barring integer overflows, there&apos;s no count of milliseconds that don&apos;t correspond to a valid DateTime, but when working with calendar units, it&apos;s pretty easy to say something like &quot;June 400th&quot;. Luxon considers that invalid and will throw an error.</p><pre><code class="lang-js"><code class="source-code prettyprint">&gt; var dt = DateTime.fromObject({ month: 6, day: 400 }); // throws!</code>
</code></pre><p>Some examples:</p><ul>
<li>February 40th</li>
<li>28:00</li>
<li>-4 pm</li>
<li>etc</li>
</ul><p>But there are other ways to do it:</p><pre><code class="lang-js"><code class="source-code prettyprint">// specify a time zone that doesn&apos;t exist
DateTime.now().setZone(&quot;America/Blorp&quot;); // throws

// provide contradictory information (here, this date is not a Wednesday)
DateTime.fromObject({ year: 2017, month: 5, day: 25, weekday: 3 }).; // throws</code>
</code></pre><p>##InvalidArgumentError</p><p>Sometimes Luxon decides that the problem isn&apos;t so much the data being wrong, but that the programmer misunderstood the interface. For that, Luxon throws an <code>InvalidArgumentError</code>.</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.now().set({ blorp: 7 }); //=&gt; kerplosion</code>
</code></pre><h2>Debugging invalid DateTimes</h2><p>Because DateTimes fail silently, they can be a pain to debug. Luxon has some features that can help.</p><h3>invalidReason and invalidExplanation</h3><p>Invalid DateTime objects are happy to tell you why they&apos;re invalid. <code>invalidReason</code> will give you a consistent error code you can use, whereas <code>invalidExplanation</code> will spell it out</p><pre><code class="lang-js"><code class="source-code prettyprint">var dt = DateTime.now().setZone(&quot;America/Blorp&quot;);
dt.invalidReason; //=&gt;  &apos;unsupported zone&apos;
dt.invalidExplanation; //=&gt; &apos;the zone &quot;America/Blorp&quot; is not supported&apos;</code>
</code></pre><h3>throwOnInvalid</h3><p>You can make Luxon throw whenever it creates an invalid DateTime. The message will combine <code>invalidReason</code> and <code>invalidExplanation</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">Settings.throwOnInvalid = true;
DateTime.now().setZone(&quot;America/Blorp&quot;); //=&gt; Error: Invalid DateTime: unsupported zone: the zone &quot;America/Blorp&quot; is not supported</code>
</code></pre><p>You can of course leave this on in production too, but be sure to try/catch it appropriately.</p><h2>Invalid Durations</h2><p>Durations can be invalid too. The easiest way to get one is to diff an invalid DateTime.</p><pre><code class="lang-js"><code class="source-code prettyprint">DateTime.local(2017, 28).diffNow().isValid; //=&gt; false</code>
</code></pre><h2>Invalid Intervals</h2><p>Intervals can be invalid. This can happen a few different ways:</p><ul>
<li>The end time is before the start time</li>
<li>It was created from invalid DateTime or Duration</li>
</ul></div>
        <a data-ice="link" href="manual/errors.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Support matrix</h1><p>This page covers what platforms are supported by Luxon and what caveats apply to them.</p><h2>Official support</h2><p>Luxon officially supports the last two versions of the major browsers, with some caveats. The table below shows which of the not-universally-supported features are available in what environments.</p><table>
<thead>
<tr>
<th>Browser</th>
<th>Versions</th>
<th>Zones</th>
<th>Intl basics</th>
<th>Intl tokens</th>
<th>Intl relative time formatting</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chrome</td>
<td>&gt;= 71</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
</tr>
<tr>
<td></td>
<td>&gt;= 54</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td>Firefox</td>
<td>&gt;= 65</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
</tr>
<tr>
<td>Edge</td>
<td>18</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td></td>
<td>16</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td>IE</td>
<td>11</td>
<td>&#x2717;</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td></td>
<td>10</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td>Safari</td>
<td>11</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td></td>
<td>10</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td>iOS Safari (iOS version numbers)</td>
<td>&gt;= 11</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td></td>
<td>10</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td></td>
<td>9</td>
<td>&#x2717;</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td>Node w/ICU</td>
<td>&gt;= 12</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
</tr>
<tr>
<td></td>
<td>&gt;= 8</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td></td>
<td>6</td>
<td>&#x2717;</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td>Node w/o ICU</td>
<td>&gt;= 8</td>
<td>&#x2713;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
</tr>
<tr>
<td></td>
<td>6</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
<td>&#x2717;</td>
</tr>
</tbody>
</table><ul>
<li>Those capabilities are explained in the next sections, along with possible polyfill options</li>
<li>&quot;w/ICU&quot; refers to providing Node with ICU data. See the <a href="./manual/install.html#node">install</a> for instructions</li>
</ul><h2>Internet Explorer and platform polyfills</h2><p>If you&apos;re supporting IE 10 or 11, you need some polyfills just to make Luxon work at all.</p><p>With IE 11, you can just add a polyfill like this to get the JS features you need:</p><pre><code class="lang-html"><code class="source-code prettyprint">&lt;script src=&quot;https://cdn.polyfill.io/v2/polyfill.js?features=default,String.prototype.repeat,Array.prototype.find,Array.prototype.findIndex,Math.trunc,Math.sign&quot;&gt;&lt;/script&gt;</code>
</code></pre><p>That hasn&apos;t checked off the other boxes in the chart above though, so keep reading for those.</p><p>With IE 10, you have the same problems as IE 11, except that you don&apos;t even get basic Intl support. You&apos;ll need to tack on the languages you wish to support. See the Basic Internationalization polyfill section below.</p><p>Alternatively, you can use a polyfilled build of Luxon, which you can find here:</p><ul>
<li><a href="./manual/../../global-filled/luxon.js">Download full polyfilled build</a></li>
<li><a href="./manual/../../global-filled/luxon.min.js">Download minified polyfilled build</a></li>
</ul><p>These use global polyfills, though, which means newer browsers will be running the injected code too. And the same doesn&apos;t-include-intl-and-zone-support caveats apply to it too.</p><h2>Effects of missing features</h2><p><strong>If the platforms you&apos;re targeting has all its boxes above check off, ignore this section</strong>.</p><p>In the support table above, you can see that some environments are missing capabilities. They affect a subset of Luxon&apos;s features that depend on specific APIs that some older browsers don&apos;t support.</p><ol>
<li><strong>Basic internationalization</strong>. Luxon doesn&apos;t have internationalized strings in its code; instead it relies on the hosts implementation of the Intl API. This includes the very handy <a href="./manual/../class/src/datetime.js~DateTime.html#instance-method-toLocaleString">toLocaleString</a>. Most browsers and recent versions of Node support this.</li>
<li><strong>Internationalized tokens</strong>. Listing the months or weekdays of a locale and outputting or parsing ad-hoc formats in non-English locales requires that Luxon be able to programmatically introspect the results of an Intl call. It does this using Intl&apos;s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts">formatToParts</a> method, which is a relatively recent addition in most browsers. So you could have the Intl API without having that.</li>
<li><strong>Zones</strong>. Luxon&apos;s support of IANA zones works by abusing the Intl API. That means you have to have that API and that the API must support a reasonable list of time zones. Zones are a recent addition to some platforms.</li>
<li><strong>Relative time formatting</strong>. Luxon&apos;s support for relative time formatting (e.g. <code>DateTime#toRelative</code> and <code>DateTime#toRelativeCalendar</code>) depends on Intl.RelativeTimeFormat, which is currently only available in Chrome and Firefox. Luxon will fall back to using English if that capability is missing.</li>
</ol><p>If the browser lacks these capabilities, Luxon tries its best:</p><table>
<thead>
<tr>
<th>Feature</th>
<th>Full support</th>
<th>No Intl at all</th>
<th>Intl but no formatToParts</th>
<th>No IANA zone support</th>
<th>No relative time format</th>
</tr>
</thead>
<tbody>
<tr>
<td>Most things</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr>
<td>Using explicit time zones</td>
<td>OK</td>
<td>Error</td>
<td>OK</td>
<td>Error</td>
<td>OK</td>
</tr>
<tr>
<td><code>DateTime#toLocaleString</code></td>
<td>OK</td>
<td>Uses English with caveats&#x2020;</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr>
<td><code>DateTime#toLocaleParts</code></td>
<td>OK</td>
<td>Empty array</td>
<td>Empty array</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr>
<td><code>DateTime#toFormat</code> in en-US</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr>
<td><code>DateTime#toFormat</code> in other locales</td>
<td>OK</td>
<td>Uses English</td>
<td>Uses English if format contains localized strings&#x2021;</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr>
<td><code>DateTime#fromFormat</code> in en-US</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr>
<td><code>DateTime#toRelative</code> in en-US</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr>
<td><code>DateTime#toRelative</code> in other locales</td>
<td>Uses English</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>Uses English</td>
</tr>
<tr>
<td><code>DateTime#offsetNameShort</code>, etc</td>
<td>OK</td>
<td>Returns null</td>
<td>OK in most locales&#xA7;</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr>
<td><code>fromFormat</code> in other locales</td>
<td>OK</td>
<td>Error if uses localized strings&#x2021;</td>
<td>Uses English if format contains localized strings&#x2021;</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr>
<td><code>Info.months</code>, etc in en-US</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr>
<td><code>Info.months</code>, etc in other locales</td>
<td>OK</td>
<td>Uses English</td>
<td>Uses English</td>
<td>OK</td>
<td>OK</td>
</tr>
</tbody>
</table><p>&#x2020; Specifically, the caveat here is that this English fallback only works as you might expect for Luxon-provided preset arguments, like <code>DateTime.DATETIME_MED</code>. If you provide your own, modify the presets, or even clone them, it will use <code>DateTime.DATETIME_HUGE</code>. If you don&apos;t provide any arguments at all, it defaults to <code>DateTime.DATE_SHORT</code>.</p><p>&#x2021; This means that Luxon can&apos;t parse anything with a word in it like localized versions of &quot;January&quot; or &quot;Tuesday&quot;. It&apos;s fine with numbers, as long as they&apos;re Western numbers.</p><p>&#xA7; This fallback uses a hack that is not guaranteed to work in every locale in every browser. It&apos;s worked where I tested it, though. It will fall back to returning <code>null</code> if it fails.</p><h2>Polyfills</h2><h3>Intl</h3><p>If your platform doesn&apos;t have any kind of Intl support (such as IE 10), you need to load them individually through a polyfill. The easiest way to that is like this:</p><pre><code class="lang-html"><code class="source-code prettyprint">&lt;script src=&quot;https://cdn.polyfill.io/v2/polyfill.js?features=Intl.~locale.zh,Intl.~locale.fr&quot;&gt;&lt;/script&gt;</code>
</code></pre><p>If you&apos;re on a platform that already needs other polyfills, just tack those features to the end of your polyfill list.</p><h3>Intl tokens</h3><p>Polyfilling Intl token support is a bit painful. This limitation applies to Edge &lt; 18 and all the IEs. Fortunately, you probably don&apos;t need Intl token support!</p><p>First, if you don&apos;t have Intl at all (e.g. as in IE 10), you are in luck. The polyfills in the previous section will give you Intl token support too!</p><p>But more likely, you have basic Intl support but not <code>formatToParts</code> (e.g. IE 11 or Edge 16). The problem here is that the polyfill service will ignore the Intl polyfills, so you won&apos;t get the support you need. Instead, you need to override all of Intl with the <a href="https://github.com/andyearnshaw/Intl.js/">Intl polyfill</a> directly. [help wanted: instructions on exactly how to do that]</p><h3>Zones</h3><p>If you have an Intl API (either natively or through the Intl polyfill above) but no zone support, you can add it via the very nice <a href="https://github.com/yahoo/date-time-format-timezone">DateTime format polyfill</a>.</p><h2>Older platforms</h2><ul>
<li><strong>Older versions of both Chrome and Firefox</strong> will most likely work. It&apos;s just that I only officially support the last two versions. As you get to older versions of these browsers, the missing capabilities listed above begin to apply to them. (e.g. FF started supporting <code>formatToParts</code> in 51 and time zones in 52). I haven&apos;t broken that out because it&apos;s complicated, Luxon doesn&apos;t officially support them, and no one runs them anyway.</li>
<li><strong>Older versions of IE</strong> probably won&apos;t work at all.</li>
<li><strong>Older versions of Node</strong> probably won&apos;t work without recompiling Luxon with a different Node target. In which case they&apos;ll work with some features missing.</li>
</ul><h2>Other platforms</h2><p>If the platform you&apos;re targeting isn&apos;t on the list and you&apos;re unsure what caveats apply, you can check which pieces are supported:</p><pre><code class="lang-js"><code class="source-code prettyprint">Info.features(); //=&gt; { intl: true, intlTokens: true, zones: true, relative: false }</code>
</code></pre><p>Specific notes on other platforms:</p><ul>
<li><strong>React Native on (specifically) Android</strong> doesn&apos;t come with Intl support, so all the possible-to-be-missing capabilities above are unavailable. Use <a href="https://github.com/SoftwareMansion/jsc-android-buildscripts">jsc-android-buildscripts</a> to fix it.</li>
</ul></div>
        <a data-ice="link" href="manual/matrix.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>For Moment users</h1><p>Luxon borrows lots of ideas from <a href="http://momentjs.com">Moment.js</a>, but there are a lot of differences too. This document clarifies what they are.</p><h2>Immutability</h2><p>Luxon&apos;s objects are immutable, whereas Moment&apos;s are mutable. For example, in Moment:</p><pre><code class="lang-js"><code class="source-code prettyprint">var m1 = moment();
var m2 = m1.add(1, &quot;hours&quot;);
m1.valueOf() === m2.valueOf(); //=&gt; true</code>
</code></pre><p>This happens because <code>m1</code> and <code>m2</code> are really the same object; <code>add()</code> <em>mutated</em> the object to be an hour later. Compare that to Luxon:</p><pre><code class="lang-js"><code class="source-code prettyprint">var d1 = DateTime.now();
var d2 = d1.plus({ hours: 1 });
d1.valueOf() === d2.valueOf(); //=&gt; false</code>
</code></pre><p>This happens because the <code>plus</code> method returns a new instance, leaving <code>d1</code> unmodified. It also means that Luxon doesn&apos;t require copy constructors or clone methods.</p><h2>Major functional differences</h2><ol>
<li>Months in Luxon are 1-indexed instead of 0-indexed like in Moment and the native Date type.</li>
<li>Localizations and time zones are implemented by the native Intl API (or a polyfill of it), instead of by the library itself.</li>
<li>Luxon has both a Duration type and an Interval type. The Interval type is like Twix.</li>
<li>Luxon lacks the relative time features of Moment and won&apos;t support it until the required <a href="https://github.com/tc39/proposal-intl-relative-time">facilities</a> are provided by the browser.</li>
</ol><h2>Other API style differences</h2><ol>
<li>Luxon methods often take option objects as their last parameter</li>
<li>Luxon has different static methods for object creation (e.g. <code>fromISO</code>), as opposed to Moment&apos;s one function that dispatches based on the input</li>
<li>Luxon parsers are very strict, whereas Moment&apos;s are more lenient.</li>
<li>Luxon uses getters instead of accessor methods, so <code>dateTime.year</code> instead of <code>dateTime.year()</code></li>
<li>Luxon centralizes its &quot;setters&quot;, like <code>dateTime.set({year: 2016, month: 4})</code> instead of <code>dateTime.year(2016).month(4)</code> like in Moment.</li>
<li>Luxon&apos;s Durations are a separate top-level class.</li>
<li>Arguments to Luxon&apos;s methods are not automatically coerced into Luxon instances. E.g. <code>m.diff(&apos;2017-04-01&apos;)</code> would be <code>dt.diff(DateTime.fromISO(&apos;2017-04-01&apos;))</code>.</li>
</ol><h2>DateTime method equivalence</h2><p>Here&apos;s a rough mapping of DateTime methods in Moment to ones in Luxon. I haven&apos;t comprehensively documented stuff that&apos;s in Luxon but not in Moment, just a few odds and ends that seemed obvious for inclusion; there are more. I&apos;ve probably missed a few things too.</p><h3>Creation</h3><table>
<thead>
<tr>
<th>Operation</th>
<th>Moment</th>
<th>Luxon</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Now</td>
<td><code>moment()</code></td>
<td><code>DateTime.now()</code></td>
<td></td>
</tr>
<tr>
<td>From ISO</td>
<td><code>moment(String)</code></td>
<td><code>DateTime.fromISO(String)</code></td>
<td></td>
</tr>
<tr>
<td>From RFC 2822</td>
<td><code>moment(String)</code></td>
<td><code>DateTime.fromRFC2822(String)</code></td>
<td></td>
</tr>
<tr>
<td>From custom format</td>
<td><code>moment(String, String)</code></td>
<td><code>DateTime.fromFormat(String, String)</code></td>
<td>The format tokens differ between Moment and Luxon, such that the same format string cannot be used between the two.</td>
</tr>
<tr>
<td>From object</td>
<td><code>moment(Object)</code></td>
<td><code>DateTime.fromObject(Object)</code></td>
<td></td>
</tr>
<tr>
<td>From timestamp</td>
<td><code>moment(Number)</code></td>
<td><code>DateTime.fromMillis(Number)</code></td>
<td></td>
</tr>
<tr>
<td>From JS Date</td>
<td><code>moment(Date)</code></td>
<td><code>DateTime.fromJSDate(Date)</code></td>
<td></td>
</tr>
<tr>
<td>From civil time</td>
<td><code>moment(Array)</code></td>
<td><code>DateTime.local(Number...)</code></td>
<td>Like <code>DateTime.local(2016, 12, 25, 10, 30)</code></td>
</tr>
<tr>
<td>From UTC civil time</td>
<td><code>moment.utc(Array)</code></td>
<td><code>DateTime.utc(Number...)</code></td>
<td>Moment also uses <code>moment.utc()</code> to take other arguments. In Luxon, use the appropriate method and pass in the <code>{ zone: &apos;utc&apos;}</code> option</td>
</tr>
<tr>
<td>Clone</td>
<td><code>moment(Moment)</code></td>
<td>N/A</td>
<td>Immutability makes this pointless; just reuse the object</td>
</tr>
<tr>
<td>Use the string&apos;s offset</td>
<td><code>parseZone</code></td>
<td>See note</td>
<td>Methods taking strings that can specify offset or zone take a <code>setZone</code> argument</td>
</tr>
</tbody>
</table><h3>Getters and setters</h3><h4>Basic information getters</h4><table>
<thead>
<tr>
<th>Property</th>
<th>Moment</th>
<th>Luxon</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Validity</td>
<td><code>isValid()</code></td>
<td>N/A, throws an error</td>
<td></td>
</tr>
<tr>
<td>Locale</td>
<td><code>locale()</code></td>
<td><code>locale</code></td>
<td></td>
</tr>
<tr>
<td>Zone</td>
<td><code>tz()</code></td>
<td><code>zone</code></td>
<td>Moment requires a plugin for this, but not Luxon</td>
</tr>
</tbody>
</table><h4>Unit getters</h4><table>
<thead>
<tr>
<th>Property</th>
<th>Moment</th>
<th>Luxon</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Year</td>
<td><code>year()</code></td>
<td><code>year</code></td>
<td></td>
</tr>
<tr>
<td>Month</td>
<td><code>month()</code></td>
<td><code>month</code></td>
<td></td>
</tr>
<tr>
<td>Day of month</td>
<td><code>date()</code></td>
<td><code>day</code></td>
<td></td>
</tr>
<tr>
<td>Day of week</td>
<td><code>day()</code>, <code>weekday()</code>, <code>isoWeekday()</code></td>
<td><code>weekday</code></td>
<td>1-7, Monday is 1, Sunday is 7, per ISO</td>
</tr>
<tr>
<td>Day of year</td>
<td><code>dayOfYear()</code></td>
<td><code>ordinal</code></td>
<td></td>
</tr>
<tr>
<td>Hour of day</td>
<td><code>hour()</code></td>
<td><code>hour</code></td>
<td></td>
</tr>
<tr>
<td>Minute of hour</td>
<td><code>minute()</code></td>
<td><code>minute</code></td>
<td></td>
</tr>
<tr>
<td>Second of minute</td>
<td><code>second()</code></td>
<td><code>second</code></td>
<td></td>
</tr>
<tr>
<td>Millisecond of seconds</td>
<td><code>millisecond()</code></td>
<td><code>millisecond</code></td>
<td></td>
</tr>
<tr>
<td>Week of ISO week year</td>
<td><code>weekYear</code>, <code>isoWeekYear</code></td>
<td><code>weekYear</code></td>
<td></td>
</tr>
<tr>
<td>Quarter</td>
<td><code>quarter</code></td>
<td>None</td>
<td>Just divide the months by 4</td>
</tr>
</tbody>
</table><h4>Programmatic get and set</h4><p>For programmatic getting and setting, Luxon and Moment are very similar here:</p><table>
<thead>
<tr>
<th>Operation</th>
<th>Moment</th>
<th>Luxon</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>get value</td>
<td><code>get(String)</code></td>
<td><code>get(String)</code></td>
<td></td>
</tr>
<tr>
<td>set value</td>
<td><code>set(String, Number)</code></td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>set values</td>
<td><code>set(Object)</code></td>
<td><code>set(Object)</code></td>
<td>Like <code>dt.set({ year: 2016, month: 3 })</code></td>
</tr>
</tbody>
</table><h3>Transformation</h3><table>
<thead>
<tr>
<th>Operation</th>
<th>Moment</th>
<th>Luxon</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Addition</td>
<td><code>add(Number, String)</code></td>
<td><code>plus(Object)</code></td>
<td>Like <code>dt.plus({ months: 3, days: 2 })</code></td>
</tr>
<tr>
<td>Subtraction</td>
<td><code>subtract(Number, String)</code></td>
<td><code>minus(Object)</code></td>
<td>Like <code>dt.minus({ months: 3, days: 2 })</code></td>
</tr>
<tr>
<td>Start of unit</td>
<td><code>startOf(String)</code></td>
<td><code>startOf(String)</code></td>
<td></td>
</tr>
<tr>
<td>End of unit</td>
<td><code>endOf(String)</code></td>
<td><code>endOf(String)</code></td>
<td></td>
</tr>
<tr>
<td>Change unit values</td>
<td><code>set(Object)</code></td>
<td><code>set(Object)</code></td>
<td>Like <code>dt.set({ year: 2016, month: 3 })</code></td>
</tr>
<tr>
<td>Change time zone</td>
<td><code>tz(String)</code></td>
<td><code>setZone(string)</code></td>
<td>Luxon doesn&apos;t require a plugin</td>
</tr>
<tr>
<td>Change zone to utc</td>
<td><code>utc()</code></td>
<td><code>toUTC()</code></td>
<td></td>
</tr>
<tr>
<td>Change local zone</td>
<td><code>local()</code></td>
<td><code>toSystemZone()</code></td>
<td></td>
</tr>
<tr>
<td>Change offset</td>
<td><code>utcOffset(Number)</code></td>
<td>None</td>
<td>Set the zone instead</td>
</tr>
<tr>
<td>Change locale</td>
<td><code>locale(String)</code></td>
<td><code>setLocale(String)</code></td>
</tr>
</tbody>
</table><h3>Query</h3><table>
<thead>
<tr>
<th>Question</th>
<th>Moment</th>
<th>Luxon</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Is this time before that time?</td>
<td><code>m1.isBefore(m2)</code></td>
<td><code>dt1 &lt; dt2</code></td>
<td>The Moment versions of these take a unit. To do that in Luxon, use <code>startOf</code> on both instances.</td>
</tr>
<tr>
<td>Is this time after that time?</td>
<td><code>m1.isAfter(m2)</code></td>
<td><code>dt1 &gt; dt2</code></td>
<td></td>
</tr>
<tr>
<td>Is this time the same or before that time?</td>
<td><code>m1.isSameOrBefore(m2)</code></td>
<td><code>dt1 &lt;= dt2</code></td>
<td></td>
</tr>
<tr>
<td>Is this time the same or after that time?</td>
<td><code>m1.isSameOrAfter(m2)</code></td>
<td><code>dt1 &gt;= dt2</code></td>
<td></td>
</tr>
<tr>
<td>Do these two times have the same [unit]?</td>
<td><code>m1.isSame(m2, unit)</code></td>
<td><code>dt1.hasSame(dt2, unit)</code></td>
<td></td>
</tr>
<tr>
<td>Is this time&apos;s [unit] before that time&apos;s?</td>
<td><code>m1.isBefore(m2, unit)</code></td>
<td><code>dt1.startOf(unit) &lt; dt2.startOf(unit)</code></td>
<td></td>
</tr>
<tr>
<td>Is this time&apos;s [unit] after that time&apos;s?</td>
<td><code>m1.isAfter(m2, unit)</code></td>
<td><code>dt1.startOf(unit) &gt; dt2.startOf(unit)</code></td>
<td></td>
</tr>
<tr>
<td>Is this time between these two times?</td>
<td><code>m1.isBetween(m2, m3)</code></td>
<td><code>Interval.fromDateTimes(dt2, dt3).contains(dt1)</code></td>
<td></td>
</tr>
<tr>
<td>Is this time inside a DST</td>
<td><code>isDST()</code></td>
<td><code>isInDST</code></td>
<td></td>
</tr>
<tr>
<td>Is this time&apos;s year a leap year?</td>
<td><code>isInLeapYear()</code></td>
<td><code>isInLeapYear</code></td>
<td></td>
</tr>
<tr>
<td>How many days are in this time&apos;s month?</td>
<td><code>daysInMonth()</code></td>
<td><code>daysInMonth</code></td>
<td></td>
</tr>
<tr>
<td>How many days are in this time&apos;s year?</td>
<td>None</td>
<td><code>daysInYear</code></td>
</tr>
</tbody>
</table><h3>Output</h3><h4>Basics</h4><p>See the <a href="./manual/formatting.html">formatting guide</a> for more about the string-outputting methods.</p><table>
<thead>
<tr>
<th>Output</th>
<th>Moment</th>
<th>Luxon</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>simple string</td>
<td><code>toString()</code></td>
<td><code>toString()</code></td>
<td>Luxon just uses ISO 8601 for this. See Luxon&apos;s <code>toLocaleString()</code></td>
</tr>
<tr>
<td>full ISO 8601</td>
<td><code>iso()</code></td>
<td><code>toISO()</code></td>
<td></td>
</tr>
<tr>
<td>ISO date only</td>
<td>None</td>
<td><code>toISODate()</code></td>
<td></td>
</tr>
<tr>
<td>ISO time only</td>
<td>None</td>
<td><code>toISOTime()</code></td>
<td></td>
</tr>
<tr>
<td>custom format</td>
<td><code>format(...)</code></td>
<td><code>toFormat(...)</code></td>
<td>The format tokens differ between Moment and Luxon, such that the same format string cannot be used between the two.</td>
</tr>
<tr>
<td>RFC 2822</td>
<td></td>
<td><code>toRFC2822()</code></td>
<td></td>
</tr>
<tr>
<td>HTTP date string</td>
<td></td>
<td><code>toHTTP()</code></td>
<td></td>
</tr>
<tr>
<td>JS Date</td>
<td><code>toDate()</code></td>
<td><code>toJSDate()</code></td>
<td></td>
</tr>
<tr>
<td>Epoch time</td>
<td><code>valueOf()</code></td>
<td><code>toMillis()</code> or <code>valueOf()</code></td>
<td></td>
</tr>
<tr>
<td>Object</td>
<td><code>toObject()</code></td>
<td><code>toObject()</code></td>
<td></td>
</tr>
<tr>
<td>Duration</td>
<td><code>diff(Moment)</code></td>
<td><code>diff(DateTime)</code></td>
<td>Moment&apos;s diff returns a count of milliseconds, but Luxon&apos;s returns a Duration. To replicate the Moment behavior, use <code>dt1.diff(d2).milliseconds</code>.</td>
</tr>
</tbody>
</table><h4>Humanization</h4><p>Luxon has <code>toRelative</code> and <code>toRelativeCalendar</code>. For internationalization, they use Intl.RelativeTimeFormat (or fall back to English when it is not supported by the browser).</p><table>
<thead>
<tr>
<th>Operation</th>
<th>Moment</th>
<th>Luxon</th>
</tr>
</thead>
<tbody>
<tr>
<td>Time from now</td>
<td><code>fromNow()</code></td>
<td><code>toRelative()</code></td>
</tr>
<tr>
<td>Time from other time</td>
<td><code>from(Moment)</code></td>
<td><code>toRelative({ base: DateTime })</code></td>
</tr>
<tr>
<td>Time to now</td>
<td><code>toNow()</code></td>
<td><code>DateTime.local().toRelative({ base: this })</code></td>
</tr>
<tr>
<td>Time to other time</td>
<td><code>to(Moment)</code></td>
<td><code>otherTime.toRelative({ base: this })</code></td>
</tr>
<tr>
<td>&quot;Calendar time&quot;</td>
<td><code>calendar()</code></td>
<td><code>toRelativeCalendar()</code></td>
</tr>
</tbody>
</table><h2>Durations</h2><p>Moment Durations and Luxon Durations are broadly similar in purpose and capabilities. The main differences are:</p><ol>
<li>Luxon durations have more sophisticated conversion capabilities. They can convert from one set of units to another using <code>shiftTo</code>. They can also be configured to use different unit conversions. See <a href="./manual/math.html#duration-math">Duration Math</a> for more.</li>
<li>Luxon does not (yet) have an equivalent of Moment&apos;s Duration <code>humanize</code> method. Luxon will add that when <a href="https://github.com/tc39/proposal-unified-intl-numberformat">Unified Intl.NumberFormat</a> is supported by browsers.</li>
<li>Like DateTimes, Luxon Durations have separate methods for creating objects from different sources.</li>
</ol><p>See the <a href="./manual/../class/src/duration.js~Duration.html">Duration API docs</a> for more.</p><h2>Intervals</h2><p>Moment doesn&apos;t have direct support intervals, which must be provided by plugins like Twix or moment-range. Luxon&apos;s Intervals have similar capabilities to theirs, with the exception of the humanization features. See the <a href="./manual/../class/src/interval.js~Interval.html">Interval API docs</a> for more.</p></div>
        <a data-ice="link" href="manual/moment.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Why does Luxon exist?</h1><p>What&apos;s the deal with this whole Luxon thing anyway? Why did I write it? How is it related to the Moment project? What&apos;s different about it? This page tries to hash all that out.</p><h2>A disclaimer</h2><p>I should clarify here that I&apos;m just one of Moment&apos;s maintainers; I&apos;m not in charge and I&apos;m not Moment&apos;s creator. The opinions here are solely mine. Finally, none of this is meant to bash Moment, a project I&apos;ve spent a lot of time on and whose other developers I respect.</p><h2>Origin</h2><p>Luxon started because I had a bunch of ideas on how to improve Moment but kept finding Moment wasn&apos;t a good codebase to explore them with. Namely:</p><ul>
<li>I wanted to try out some ideas that I thought would provide a better, more explicit API but didn&apos;t want to break everything in Moment.</li>
<li>I had an idea on how to provide out-of-the-box, no-data-files-required support for time zones, but Moment&apos;s design made that difficult.</li>
<li>I wanted to completely rethink how internationalization worked by using the Intl API that comes packaged in browsers.</li>
<li>I wanted to use a modern JS toolchain, which would require a major retrofit to Moment.</li>
</ul><p>So I decided to write something from scratch, a sort of modernized Moment. It&apos;s a combination of all the things I learned maintaining Moment and Twix, plus a bunch of fresh ideas. I worked on it in little slivers of spare time for about two years. But now it&apos;s ready to actually use, and the Moment team likes it enough that we pulled it under the organization&apos;s umbrella.</p><h2>Ideas in Luxon</h2><p>Luxon is built around a few core ideas:</p><ol>
<li>Keep the basic chainable date wrapper idea from Moment.</li>
<li>Make all the types immutable.</li>
<li>Make the API explicit; different methods do different things and have well-defined options.</li>
<li>Use the Intl API to provide internationalization, including token parsing. Fall back to English if the browser doesn&apos;t support those APIs.</li>
<li>Abuse the Intl API horribly to provide time zone support. Only possible for modern browsers.</li>
<li>Provide more comprehensive duration support.</li>
<li>Directly provide interval support.</li>
<li>Write inline docs for everything.</li>
</ol><p>These ideas have some big advantages:</p><ol>
<li>It&apos;s much easier to understand and debug code that uses Luxon.</li>
<li>Using native browser capabilities for internationalization leads to a much better behavior and is dramatically easier to maintain.</li>
<li>Luxon has the best time zone support of any JS date library.</li>
<li>Luxon&apos;s durations are both flexible and easy to use.</li>
<li>The documentation is very good.</li>
</ol><p>They also have some disadvantages:</p><ol>
<li>Using modern browser capabilities means that the fallback behavior introduces complexity for the programmer.</li>
<li>Never keeping internationalized strings in the code base means that some capabilities have to wait until the browsers provide it.</li>
<li>Some aspects of the Intl API are browser-dependent, which means Luxon&apos;s behavior is too.</li>
</ol><h2>Place in the Moment project</h2><p>Luxon lives in the Moment project because, basically, we all really like it, and it represents a huge improvement.</p><p>But Luxon doesn&apos;t quite fulfill Moment&apos;s mandate. Since it sometimes relies on browsers&apos; implementations of the <code>Intl</code> specifications, it doesn&apos;t provide some of Moment&apos;s most commonly-used features on all browsers. Relative date formatting is for instance not supported in IE11 and Safari (as of August 2020). Luxon&apos;s Intl features do not work as expected on sufficiently outdated browsers, whereas Moment&apos;s all work everywhere. That represents a good tradeoff, IMO, but it&apos;s clearly a different one than Moment makes.</p><p>Luxon makes a major break in API conventions. Part of Moment&apos;s charm is that you just call <code>moment()</code> on basically anything and you get date, whereas Luxon forces you to decide that you want to call <code>fromISO</code> or whatever. The upshot of all that is that Luxon feels like a different library; that&apos;s why it&apos;s not Moment 3.0.</p><p>So what is it then? We&apos;re not really sure. We&apos;re calling it a Moment labs project. Will its ideas get backported into Moment 3? Will it gradually siphon users away from Moment and become the focus of the Moment project? Will the march of modern browsers retire the arguments above and cause us to revisit branding Luxon as Moment? We don&apos;t know.</p><p>There, now you know as much as I do.</p><h2>Future plans</h2><p>Luxon is fully usable and I plan to support it indefinitely. It&apos;s also largely complete. Luxon will eventually strip out its fallbacks for missing platform features. But overall I expect the core functionality to stay basically as it is, adding mostly minor tweaks and bugfixes.</p></div>
        <a data-ice="link" href="manual/why.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Changelog</h1><h2>before 2.0.0</h2><p> Refer to Luxon&apos;s changelog </p><h2>2.0.1</h2><ul>
<li>Fixed DateTime.hasSame comparison </li>
</ul><h2>2.0.2</h2><ul>
<li>Added tslint</li>
<li>Improved naming convention</li>
<li>Solved Intl issue when compiling Angular (improved Intl namespace declaring and merging until es2020.intl)</li>
</ul></div>
        <a data-ice="link" href="manual/CHANGELOG.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Contributing to Luxon</h1><h2>General guidelines</h2><p>Patches are welcome. Luxon is at this point just a baby and it could use lots of help. But before you dive in...Luxon is one of those tightly-scoped libraries where the default answer to &quot;should this library do X?&quot; is likely &quot;no&quot;. <strong>So ask first!</strong> It might save you some time and energy.</p><p>Here are some vague notes on Luxon&apos;s design philosophy:</p><ol>
<li>We won&apos;t accept patches that can&apos;t be internationalized using the JS environment&apos;s (e.g. the browser&apos;s) native capabilities. This means that most convenient humanization features are out of scope.</li>
<li>We try hard to have a clear definition of what Luxon does and doesn&apos;t do. With few exceptions, this is not a &quot;do what I mean&quot; library.</li>
<li>Luxon shouldn&apos;t contain simple conveniences that bloat the library to save callers a couple lines of code. Write those lines in your own code.</li>
<li>Most of the complexity of JS module loading compatibility is left to the build. If you have a &quot;this can&apos;t be loaded in my bespoke JS module loader&quot; problems, this isn&apos;t something you should be solving with changes to the <code>src</code> directory. If it&apos;s a common use case and is possible to generate with Rollup, it can get its own build command.</li>
<li>We prefer documentation clarifications and gotchas to go in the docstrings, not in the guides on the docs page. Obviously, if the guides are wrong, they should be fixed, but we don&apos;t want them to turn into troubleshooting pages. On the other hand, making sure the method-level documentation has ample examples and notes is great.</li>
<li>You&apos;ll need to sign a CLA as part of your first pull request to Luxon.</li>
</ol><h2>Building and testing</h2><p>Building and testing is done through npm scripts. The tests run in Node and require Node 10+ with full-icu support. This is because some of the features available in TS-Luxon (like internationalization and time zones) need that stuff and we test it all. On any platform, if you have Node 10 installed with full-icu, you&apos;re good to go; just run npm scripts like <code>npm run test</code>. But you probably don&apos;t have that, so read on.</p><p><strong>IMPORTANT: your tests will likely fail if you&apos;re not in Italy, that&apos;s why I strongly suggest using docker for a guaranteed success!</strong></p><h3>OSX</h3><p>Mac is easy:
Open the terminal.</p><pre><code><code class="source-code prettyprint">brew install node --with-full-icu
npm install
./scripts/test</code>
</code></pre><p>If that&apos;s for whatever reason a pain, the Linux instructions should also work, as well as the Docker ones.</p><h3>Linux</h3><p>There are two ways to get full-icu support in Linux: build it with that support, or provide it as a module. We&apos;ll cover the latter. Assuming you&apos;ve installed Node 10:</p><pre><code><code class="source-code prettyprint">npm install
npm install full-icu
./scripts/test</code>
</code></pre><p>Where <code>scripts/test</code> is just <code>NODE_ICU_DATA=&quot;$(pwd)/node_modules/full-icu&quot; npm run test</code>, which is required for making Node load the full-icu module you just installed. You can run all the other npm scripts (e.g. <code>npm run docs</code>) directly; they don&apos;t require Intl support.</p><h3>Windows</h3><p>If you have <a href="https://git-scm.com/downloads">Bash</a> or <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">WSL</a>, the Linux instructions seem to work fine.</p><p>I would love to add instructions for a non-WSL install of the dev env!</p><h3>Docker</h3><p>In case messing with your Node environment just to run TSLuxon&apos;s tests is too much to ask, we&apos;ve provided a Docker container.
You&apos;ll need a functioning Docker environment, but the rest is easy:</p><p>ON BOTH UNIX OR WINDOWS this will build a local image with your sources</p><pre><code><code class="source-code prettyprint"># cd /path/to/ts-luxon-folder 
# docker build -t tonysamperi/ts-luxon -f ./docker/Dockerfile .</code>
</code></pre><p>ON UNIX</p><pre><code><code class="source-code prettyprint"># docker run --rm -v ${pwd}/ts-luxon -w /tonysamperi/ts-luxon tonysamperi/ts-luxon ./docker/workflow.sh</code>
</code></pre><p>ON WINDOWS:</p><pre><code><code class="source-code prettyprint"># docker run --rm -v %CD%:/ts-luxon -w /tonysamperi/ts-luxon tonysamperi/ts-luxon ./docker/workflow.sh</code>
</code></pre><p>If you get to the tests and all the tests passed, then you&apos;re good! :)</p><h2>Patch basics</h2><p>Once you&apos;re sure your bugfix or feature makes sense for TSLuxon, make sure you take these steps:</p><ol>
<li>Be sure to add tests and run them with <code>scripts/test</code></li>
<li>Be sure you run <code>npm run lint</code> before you commit. Note this will modify your source files to line up with the style guidelines.</li>
<li>Make sure you add or ESDoc annotations appropriately. You can run <code>npm run docs</code> to generate the HTML for them. They land in the <code>build/docs</code> directory. This also builds the markdown files in <code>/docs</code> into the guide on the Luxon website.</li>
<li>To test TSLuxon in your browser, run <code>npm run site</code> and then open <code>build/demo/global.html</code>. You can access TSLuxon classes in the console like <code>window.luxon.DateTime</code>.</li>
<li>To test in Node, run <code>npm run build</code> and then run something like <code>var DateTime = require(&apos;./build/cjs/luxon&apos;).DateTime</code>.</li>
</ol><p>Luxon uses <a href="https://github.com/typicode/husky">Husky</a> to run the formatter on your code as a pre-commit hook. You should still run <code>npm run lint!</code> yourself to catch other issues, but this hook will help prevent you from failing the build with a trivial formatting error.</p><h2>npm script reference</h2><table>
<thead>
<tr>
<th>Command</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>npm run build</code></td>
<td>Build all the distributable files</td>
</tr>
<tr>
<td><code>npm run test</code></td>
<td>Run the test suite, but see notes above</td>
</tr>
<tr>
<td><code>npm run lint</code></td>
<td>Run the formatter and the linter</td>
</tr>
<tr>
<td><code>npm run docs</code></td>
<td>Build the doc pages</td>
</tr>
<tr>
<td><code>npm run site</code></td>
<td>Build the TSLuxon website</td>
</tr>
<tr>
<td><code>npm run check-doc-coverage</code></td>
<td>Check whether there&apos;s full doc coverage</td>
</tr>
</tbody>
</table></div>
        <a data-ice="link" href="manual/CONTRIBUTING.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>


<script src="https://moment.github.io/luxon/global/luxon.js"></script><script>console.log('You can try Luxon right here using the `luxon` global, like `luxon.DateTime.now()`.')</script></body></html>